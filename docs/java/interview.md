


## 项目经验

#### 一个字符串怎么判断有多少单词，代码怎么写。

```java
public static int countSegments(String s) {
    int segmentCount = 0;
    for (int i = 0; i < s.length(); i++) {
        if ((i == 0 || s.charAt(i - 1) == ' ') && s.charAt(i) != ' ') {
            segmentCount++;
        }
    }
    return segmentCount;
}
 public static int countSegments2(String s) {
        int count = 0;
        String[] strs = s.split(" ");
        for (int i = 0; i < strs.length; i++) {
            if (!"".equals(strs[i])) {
                count++;
            }
        }
        return count;
    }
```

#### 多并发 多个用户并发 怎么处理？

* 加锁。加锁是比较常用的方法。从系统的架构上来说，锁被分为单机锁和分布式锁。如果系统只是部署在单一机器上，可以简单通过java提供的各种锁来进行操作。如果系统被部署在多台机器上，可以使用redis来实现分布式加锁。这两种加锁方式从某种意义上来说是悲观锁。上述的问题，我们可以使用商品的唯一属性，比如id或者商品的唯一条码来进行加锁。

* 数据库乐观锁。数据库乐观锁几乎适用于所有的并发场景。使用方法：在数据库表中增加一个版本号字段，每一次更新和删除时把当前持有的对象版本号和数据库中最新的版本号进行比对，如果相同则验证通过，不然则操作失败。

* 使用消息队列。这种方式在消息过多时，对库存的处理可能不会特别及时。由于库存一般是需要比较及时的可见，所以这种方式并不建议。

#### 线程池怎么设置？

```yaml
mall:
  thread:
    max-size: 200
    keep-alive-time: 10
    core-pool-size: 20
```

```java
@EnableConfigurationProperties(ThreadPoolConfigProperties.class)
@Configuration
public class MyThreadConfig {
    @Bean
    public ThreadPoolExecutor threadPoolExecutor(ThreadPoolConfigProperties pool) {
        return new ThreadPoolExecutor(pool.getCorePoolSize(),
                pool.getMaxSize(),
                pool.getKeepAliveTime(),
                TimeUnit.SECONDS,
                new LinkedBlockingDeque<>(100000),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.AbortPolicy());
    }
}
```

#### 加密算法 

1. 对称加密

对称加密指的就是[加密](https://so.csdn.net/so/search?q=加密&spm=1001.2101.3001.7020)和解密使用同一个秘钥，所以叫做对称加密。对称加密只有一个秘钥，作为私钥。

2. 非对称加密

非对称加密指的是：加密和解密使用不同的秘钥，一把作为公开的公钥，另一把作为私钥。公钥加密的信息，只有私钥才能解密。私钥加密的信息，只有公钥才能解密。



常见的非对称加密算法：RSA，ECC

MD5算法：

经常用于确保信息传输的完整性和一致性 。MD5 输入不定长度信息，经过程序流程，生成四个32位数据，最后联合起来输出固定128bit长度的信息摘要。计算的基本过程为：求余、取余、调整长度、与链接变量进行循环运算、得出结果

MD5特点：

* 压缩性：任意长度的数据，算出的MD5值长度都是固定的。
* 容易计算：从原数据计算出MD5值很容易。

- 抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。
- 弱抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。
- 强抗碰撞：想找到两个不同的数据，使它们具有相同的MD5值，是非常困难的。

应用场景

* DES/AES加密速度快，适合大量数据，处理数据后可复原。

* MD5用于完整性，确保信息在传输过程保持一致性；用于密码加密，数据库中不存储密码明文，而是存储其散列值，校验时比较散列值是否相同。

* MD5在论坛上、软bai件发布时经常用，是为了保证文件du的正确性，防止一些zhi人盗用程序，dao加些木马或者篡改版权，设计的一套验证系统。每个文件都可以用MD5验证程序算出一个固定的MD5码来。



#### 如何保证推送的实时性。

#### 用户认证怎么做的

SpringSecurity是一个强大的可高度定制的认证和授权框架，对于Spring应用来说它是一套Web安全标准。SpringSecurity注重于为Java应用提供认证和授权功能，像所有的Spring项目一样，它对自定义需求具有强大的扩展性。

> JWT是JSON WEB TOKEN的缩写，它是基于 RFC 7519 标准定义的一种可以安全传输的的JSON对象，由于使用了数字签名，所以是可信任和安全的。

#### JWT的组成

- JWT token的格式：header.payload.signature
- header中用于存放签名的生成算法

#### token令牌如何使用。

Token是首次登陆时由服务器下发，作为客户端进行请求的一个令牌，当交互时用于身份验证的一种验证机制，当第一次登录后，服务器生成一

#### Token的作用

- Token完全由应用程序进行管理，所以它可以避开同源策略
- Token可以避免CSRF（跨站请求访问）攻击
- Token可以是无状态的，可以在多个服务器之间共享
- 使用Token减轻服务器的压力，减少频繁的查询数据库。

Token的验证过程

1. 客户端使用用户名跟密码请求登录
2. 服务端收到请求，去验证用户名与密码 ；
3. 验证成功后，服务端会签发一个 Token，再把这个 Token发送给客户端 ；
4. 客户端收到 Token 以后可以把它存储起来，比如放在Cookie、 Local Storage、Session Storage中；
5. 客户端每次向服务端请求资源的时候需要带着服务端签发的Token ；
6. 服务端收到请求，采用filter过滤器，校验客户端请求带着的 Token，校验成功则返回请求数据，校验失败则返回错误码。

#### 如何做定时任务的？

cron表达式通常是一个字符串，这个字符串一般由5个或者6个空格隔开，分为6域或者7域，例如："0 0 1 * * ?"是6域的，表示每天的凌晨1点执行一次任务；"0 0 1 * * ? 2019"是7域的，表示2019年的每天凌晨1点执行一次任务。

```java
@Component
@Slf4j
public class HotTagTasks {
    @Scheduled(fixedRate = 1000 * 60 * 60 * 3)
    public void hotTagSchedule() {
    }
    @Scheduled(cron = "0 0/1 8-20 * * ?")
    public void cron(){
        System.out.println("cron打印时间："+new Date());
    }
}
```

#### 如何实现拦截器？

```java
@Configuration
public class MallWebConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new CartInterceptor()).addPathPatterns("/**");
    }
}
```

```java
@Component
public class CartInterceptor implements HandlerInterceptor {
    /**
     * 在目标方法执行之前拦截
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response,
                             Object handler) throws Exception {
    }
    /**
     * 业务执行之后,分配临时用户
     */
    @Override
    public void postHandle(HttpServletRequest request,HttpServletResponse response, 
                           Object handler,ModelAndView modelAndView) throws Exception {
    }
}
```



#### 项目中设计的安全问题？

1、如何解决跨域问题？

2、如何防止sql注入问题？

3、防止XSS攻击的过滤器

XSS跨站脚本攻击的基本原理和SQL注入攻击类似，都是利用系统执行了未经过滤的危险 代码，不同点在于XSS是一种基于网页脚本的注入方式，也就是将脚本攻击载荷写入网 页执行以达到对网页客户端访问用户攻击的目的，属于客户端攻击。

#### 异常处理怎么做？

@RestControllerAdvice

 @ExceptionHandler(AccessDeniedException.class)

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    private static final Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    /**
     * 权限校验异常
     */
    @ExceptionHandler(AccessDeniedException.class)
    public AjaxResult handleAccessDeniedException(AccessDeniedException e, HttpServletRequest request) {
        String requestURI = request.getRequestURI();
        log.error("请求地址'{}',权限校验失败'{}'", requestURI, e.getMessage());
        return AjaxResult.error(HttpStatus.FORBIDDEN, "没有权限，请联系管理员授权");
    }
}

```

```java
public class AccessDeniedException extends RuntimeException {
    private String message;
    private Integer code;

    public CustomizeException(ICustomizeErrorCode errorCode) {
        this.code = errorCode.getCode();
        this.message = errorCode.getMessage();
    }

    @Override
    public String getMessage() {
        return message;
    }
    public Integer getCode() {
        return code;
    }
}
```

#### Tomcat配置

```yaml
# 开发环境配置
server:
  tomcat:
    # tomcat的URI编码
    uri-encoding: UTF-8
    # 连接数满后的排队数，默认为100
    accept-count: 1000
    threads:
      # tomcat最大线程数，默认为200
      max: 800
      # Tomcat启动初始化的线程数，默认值10
      min-spare: 100
```

#### 数据校验

#### 自定义注解

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
public @interface CheckTooFrequentCommit {
}
```

```java
@Override
public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        if (handler instanceof HandlerMethod) {
            //某一些提交的请求需要拦截
            HandlerMethod handlerMethod = (HandlerMethod) handler;
            CheckTooFrequentCommit methodAnnotation = handlerMethod.getMethodAnnotation(CheckTooFrequentCommit.class);
            if (methodAnnotation != null) {
                log.info("check commit too frequent.....");
            }
        }
        //true表示放行
        ///false表示拦截
        return true;
}
```

#### 如何防止表单重复提交?

* 给数据库增加唯一键约束

在数据库建表的时候在ID字段添加主键约束，用户名、邮箱、电话等字段加唯一性约束。确保数据库只可以添加一条数据。

数据库加唯一性约束sql：

```cobol
alter table tableName_xxx add unique key uniq_xxx(field1, field2)
```

* 使用AOP自定义切入实现

实现原理：

1. 自定义防止重复提交注解（@AvoidRepeatableCommit）。

2. 对需要防止重复提交的Congtroller里的mapping方法加上该注解。

3. 新增Aspect切入点，为注解加入切入点。

4. 每次提交表单时，Aspect都会保存当前key到reids（须设置过期时间）。

5. 重复提交时Aspect会判断当前redis是否有该key，若有则拦截。

   

#### 用户暴增千万如何优化项目?

* 数据层: sql语句优化、加索引、分表、考虑使用缓存

* 网络层: 优化网络、压缩数据、比如批量导入

* 业务层: 优化代码逻辑、考虑业务分层、耗时的业务考虑异步处理、html静态分离

* 服务层:考虑使用集群模式、负载均衡



#### 接口性能优化?

* 数据量比较大，批量操作数据入库

* 耗时操作考虑异步处理
* 合理使用缓存
* 优化SQL(加索引、避免返回不必要的数据、优化sql结构、分库分表、读写分离)
* 考虑使用消息队列

#### sql优化经验？

* 加索引
* 避免返回不必要的数据

-  适当分批量进行
-  优化 sql 结构
-  分库分表
-  读写分离

## Java基础

* 类：具有共同属性和行为的对象的抽象。类是创建对象的模板。

* 对象：现实世界中的实体。在计算机中，是指可标识的存储区域。

* 类是对象的抽象、对象是类的实例。

#### 面向对象的特征有哪些方面？

- 抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽 象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的 细节是什么。
- 继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类 被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让 变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要 手段。
- 封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问 只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自 治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写 一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西， 只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别， 明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是 封装得足够好的，因为几个按键就搞定了所有的事情）。
- 多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。 简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分 为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的 服务，那么运行时的多态性可以解释为：当 A 系统访问 B 系统提供的服务时，B 系统有多种提供服务的方式，但一切对 A 系统来说都是透明的（就像电动剃须 刀是 A 系统，它的供电系统是 B 系统，B 系统可以使用电池供电或者用交流电， 甚至还有可能是太阳能，A 系统只会通过 B 类对象调用供电的方法，但并不知道 供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载 （overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override） 实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的 东西，要实现多态需要做两件事：1). 方法重写（子类继承父类并重写父类中已 有的或抽象的方法）；2). 对象造型（用父类型引用引用子类型对象，这样同样 的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。

#### 什么是字节码?

* 在 Java 中，JVM可以理解的代码就叫做字节码（即扩展名为 .class 的文件）
* 它不面向任何特定的处理器，只面向虚拟机。

#### 采用字节码的好处是什么? 

* Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java程序无须重新编译便可在多种不同操作系统的计算机上运行。

#### 为什么说 Java 语言“编译与解释并存”？

* java源文件通过JDK中的javac编译成[字节码](https://so.csdn.net/so/search?q=字节码&spm=1001.2101.3001.7020)文件，字节码文件到机器码这一步，JVM类加载器首先需要加载字节码文件，然后通过解释器逐行解释执行。行解释执行字节码文件中的某些方法和代码时，有部分代码重复执行，为提高效率，即时[编译器](https://so.csdn.net/so/search?q=编译器&spm=1001.2101.3001.7020)将这部分字节码的机器码保存下来，就不需要重复解释。下次直接使用 

#### 什么是方法的返回值？

* 方法的返回值是某个方法体中的代码执行后产生的结果。

#### 方法有几种类型？

#### Java8有哪些新特性？

* Lambda表达式；

* 方法引用；

  * 引用类方法 
    * 格式：类名::静态方法
    * 范例：Integer::parseInt

  * 引用对象的实例方法
    * 格式：对象::成员方法
    * 范例：“HelloWorld”::toUpperCase

  * 引用类的实例方法
    * 格式：类名::成员方法
    * 范例：String::subString

  * 引用构造器
    * 格式：类名::new
    * 范例：Student::new

* 接口默认方法

* Stream流

```
foreach() filter()

map() 将流中的元素映射到另一个流

flatmap() 一对多
```

#### Java 泛型了解么？什么是类型擦除？

* 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。

* 泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。

* Java的泛型是伪泛型，这是因为Java在编译期间，所有的泛型信息都会被擦掉

* 分类：泛型类、泛型接口、泛型方法。

#### 介绍一下常用的通配符

* ？ 表示不确定的 java 类型
* T (type) 表示具体的一个java类型
* K V (key value) 分别代表java键值中的Key Value
* E (element) 代表Element

#### java中的重写和覆盖有什么区别，这样设计有什么优势？是否在项目中使用过，能否举个例子？

- 方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性， 而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同 的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；
- 重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里 氏代换原则）。重载对返回类型没有特殊的要求。

#### 抽象类和接口的区别？

- 抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。
- 一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。
- 而接口中不能定义构造器而且其 中的方法全部都是抽象方法。
- 抽象类中的成员可以是 private、默认、protected、 public 的，而接口中的成员全都是 public 的。
- 抽象类中可以定义成员变量，而接 口中定义的成员变量实际上都是常量。
- 有抽象方法的类必须被声明为抽象类，而 抽象类未必要有抽象方法。

#### 什么是反射？

* 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性，这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。

#### java反射如何获取类名 ？

1. Class.forName("全类名")：将字节码文件加载进内存，返回Class对象

2. 类名.class：通过类名的属性class获取

3. 对象.getClass()：getClass()方法在Object类中定义着。

TestClass.class.getName()

#### 什么是序列化？

- 序列化机制可以将对象转换成字节序列，这些字节序列可以保存到磁盘上，也可以在网络中传输，并且程序可以将这些字节序列恢复成原来的对象。其中，序列化（Serialize）是指将一个Java对象写入IO流中，而反序列化（Deserialize）则是指从IO流中恢复这个Java对象。
- 如果对象要支持序列化机制，则它的类需要实现Serializable接口。该接口只是一个标记接口，它没有提供任何方法，只是用来标明该类是可以序列化的。在Java中很多类都已经实现了Serializable接口，比如包装类、String、Date等。
- 在实现序列化和反序列化的时候，我们需要使用ObjectInputStream和ObjectOutputStream这两个

#### java中的深拷贝与浅拷贝有什么区别？

- **浅拷贝**：浅拷贝会在堆上创建一个新的对象，不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。
- **深拷贝** ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象
- **那什么是引用拷贝呢？** 引用拷贝就是两个不同的引用指向同一个对象。

#### java中如何实现深拷贝？

## 集合

#### 如何实现一个线程同步的hashMap?



#### 静态变量和实体变量有什么区别？这样设计在使用中有什么好处？

- 静态变量属于类，该类不生产对象，通过类名就可以调用静态变量。
- 实例变量属于该类的对象，必须产生该类对象，才能调用实例变量。
- 静态变量存储在方法区,属于类所有.实例变量存储在堆当中,其引用存在当前线程栈。

#### HashMap和HashTable有什么区别？他们底层数据结构是什么样的？

- HashMap和Hashtable都实现了Map接口，因此很多特性非常相似。但是，他们有以下不同点：
- HashMap允许键和值是null，而Hashtable不允许键或者值是null。
- Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。
- HashMap提供了可供应用迭代的键的集合，因此，HashMap是快速失败的。另一方面，Hashtable提供了对键的列举(Enumeration)。
- 一般认为Hashtable是一个遗留的类。

#### HashMap的扩容机制？

1. HasMap初始化的时候，会指定初始化大小，以及扩展阀值，如果不指定，就使用默认值，此时数组为null;
2. 向HashMap中存值的时候，如果数组为null或者为空,开始第一次扩容，创建初始化大小的数组，默认为16
3. 如果当链表的长度达到8，同时数组的长度小于64，进行扩容
4. 如果当hashMap的元素总量达到了阀值，进行扩容
5. 扩容每次将容量翻一番

#### map.put(k,v)实现原理

1. 首先将k,v封装到Node对象当中（节点）。
2. 然后它的底层会调用K的hashCode()方法得出hash值。
3. 通过哈希表函数/哈希算法，将hash值转换成数组的下标，下标位置上如果没有任何元素，就把Node添加到这个位置上。如果说下标对应的位置上有链表。此时，就会拿着k和链表上每个节点的k进行equal。如果所有的equals方法返回都是false，那么这个新的节点将被添加到链表的末尾。如其中有一个equals返回了true，那么这个节点的value将会被覆盖。

#### 解决哈希冲突方法

* 开放定址法：所谓的开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入 

* 再哈希法: 再哈希法又叫双哈希法，有多个不同的Hash函数，当发生冲突时，使用第二个，第三个，….，等哈希函数
  计算地址，直到无冲突。虽然不易发生聚集，但是增加了计算时间。

* 链地址法:链地址法的原理时如果遇到冲突，他就会在原地址新建一个空间，然后以链表结点的形式插入到该空间。

#### 如果要使用线程安全的Map该使用哪个集合？

* HashTable

* SynchronizedMap

* ConcurrentHashMap

#### 线程安全的List

## 多线程

#### 并发编程三要素？

1. **原子性:** 一个不可再被分割的颗粒。原子性指的是一个或多个操作要么全部执行成功要么全部执行失败。
2. **有序性:** 程序执行的顺序按照代码的先后顺序执行。（处理器可能会对指令进行重排序）
3. **可见性:** 一个县城对共享变量的修改,另一个线程能够立刻看到。

#### 你会在什么情况下使用多线程？

* 使用多线程主要原因是提高系统的资源利用率。

* 在工作中多线程也是常见的，比如Tomcat每处理一个请求都会从线程连接池中取一个线程处理。

多线程一般用于：

* 一些并发量大的场景，比如读入大量文件写入数据库，使用多线程可以提高效率。

* 出现耗时比较长的业务，比如用户注册之后，要发送邮件，或短信之类的操作，这些任务就算失败了也不是很重要，可以使用异步线程去处理。

* 定时任务，比如定期更新配置文件，备份数据之类的任务。

#### 线程与进程的区别？

- 进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。
- 一个程序至少有一个进程,一个进程至少有一个线程。

#### 什么是线程池？

* 线程池就是提前创建若干个线程，如果有任务需要处理，线程池里的线程就会处理任务，处理完之后线程并不会被销毁，而是等待下一个任务。
* 由于创建和销毁 线程都是消耗系统资源的，所以当你想要频繁的创建和销毁线程的时候就可以考 虑使用线程池来提升系统的性能。

优点：

1. 重用存在的线程，减少对象创建销毁的开销。
2. 可有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。 
3. 提供定时执行、定期执行、单线程、并发数控制等功能。

#### 线程池的参数？

- int corePoolSize：线程池中的常驻核心线程数
- int maximumPoolSize: 线程池能容纳同时执行的最大线程数，此值必须大于等于1
- long keepAliveTime: 多余的空闲线程的存活时间，当前池中线程数量超过corePoolSize时，当空闲时间达到keepAliveTime时，多余线程就会被销毁到只剩下corePoolSize为止
- TimeUnit unit:keepAliveTime的单位
- BlockingQueue<Runnable> workQueue: 任务队列，被提交但尚未执行的任务
- ThreadFactory threadFactory: 创建线程的工厂，默认即可
- RejectedExecutionHandler handler : 拒绝策 略，当队列满（maximumPoolSize）时，根据该handler决定如何拒绝请求执行的runnable

```java
new ThreadPoolExecutor(pool.getCorePoolSize(),
                pool.getMaxSize(),
                pool.getKeepAliveTime(),
                TimeUnit.SECONDS,
                new LinkedBlockingDeque<>(100000),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.AbortPolicy());
```



#### 线程池工作流程？

1. 在创建了线程池后，开始等待请求。

2. 当调用execute()方法添加一个请求任务时，线程池会做出如下判断: 

   2.1 如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务; 

   2.2 如果正在运行的线程数量大于或等corePoolSize，那么将这个任务放入队列; 

   2.3 如果这个时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非 核心线程立刻运行这个任 务; 

   2.4 如果队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和 拒绝策略来执行。

3. 当一个线程完成任务时，它会从队列中取下一个任务来执行。 

4. 当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断: 如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成 后，它最终会收缩 corePoolSize的大小。

#### 线程池拒绝策略？

- AbortPolicy(默认):直接抛出RejectedExecutionException异常阻止系统正常运行
- CallerRunsPolicy:“调用者运行”一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将 某些任务回退到调用者， 而降低新任务的流量。（比如是main线程提交的任务，就回退给main线程执行
- DiscardOldestPolicy:抛弃队列中等待最久的任务，然后把当前任务加人队列中尝试再次提交当前 任
- DiscardPolicy该策略默默地丢弃无法处理的任务，不予任何处理也不抛出异常。如果允许任务丢 失，这是最好的一种策略。

#### 创建四种线程池

- newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。

- newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。

- newScheduledThreadPool 创建一个定时线程池，支持定时及周期性任务执行。

- newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。

#### 阻塞队列

* 数组阻塞队列(ArrayBlockingQueue) ：底层基于数组的有界阻塞队列，初始化时需要指定队列大小
* 链表阻塞队列(LinkedBlockingQueue) ：以链表来存储元素，理论上只要存储空间够大，就是无界的
* 同步阻塞队列(SynchronousQueue)：队列中不存储元素，队列中放入元素后，只有该元素被消费完成，才能重修放入元素
* 优先级无界阻塞队列(PriorityBlockingQueue)：底层基于数组的无界队列，支持队列内部按照指定元素排序
* 链表阻塞双端队列(LinkedBlockingDeque)：底层基于链表的有界双端阻塞队列；
* 延迟无界阻塞队列(DelayQueue)：底层是基于数组的无界延迟队列，它是在PriorityQueue基础上实现的，先按延迟优先级排序，延迟时间短的排在队列前面；
* 链表阻塞队列与同步阻塞队列结合(LinkedTransferQueue)：基于链表的无界阻塞队列；

## 锁



#### 什么情况会出现线程死锁？

* 死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成 的一种互相等待的现象，若无外力作用，它们都将无法推进下去。 产生死锁的必要条件： 

1. 互斥条件：所谓互斥就是进程在某一时间内独占资源。 
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件:进程已获得资源，在末使用完之前，不能强行剥夺。 
4. 环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

#### 悲观锁？

* 对于并发间操作产生的线程安全问题持悲观状 态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个 独占的锁，就像 synchronized，不管三七二十一，直接上了锁就操作资源了。

#### 乐观锁？

* 对于并发间操作产生的线程安全问题持乐观状态， 乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应 该有相应的重试逻辑。

#### 公平锁

* 按照持有锁的顺序执行。

* synchronized非公平锁

* ReentrantLock两者都可以，默认公平锁。主要看构造方法的boolean值。

#### 非公平锁

* 不按照持有锁的顺序执行

#### 可重入锁

* 指的是同一线程外层函数获得锁之后，内层[递归函数](https://so.csdn.net/so/search?q=递归函数&spm=1001.2101.3001.7020)仍然有获取该锁的代码

* synchronized 和ReentrantLock都是可重入锁

#### CAS的理解?

* CAS 是 compare and swap 的缩写，即我们所说的比较交换。 cas 是一种基于锁的操作，而且是乐观锁

* CAS 操作包含三个操作数 —— 内存位置(V)、预期原值(A)和新值(B)。如 果内存地址里面的值V和 A 的值是一样的，那么就将内存里面的值更新成 B。CAS 是通过无限循环来获取数据的，若果在第一轮循环中，a 线程获取地址里面的值被 b 线程修改了，那么 a 线程需要自旋，到下次循环才有可能机会执行。

#### AQS的理解？



#### 说一说synchronized的实现原理？

* synchronized的底层是采用Java对象头来存储锁信息的，并且还支持锁升级。

#### synchronized和lock的区别

- 原始构成：
  - synchronized是关键字属于JVM层面，monitorenter(底层是通过monitor对象来完成，其实wait/notify等方法也依赖于monitor对象只有在同步块或者方法中才能调用wait/notify)
  - lock是类，是api层面的锁
- 使用方法：
  - synchronized不需要手动释放锁，当synchronized代码执行完以后系统会自动让线程释放对锁的占用，
  - ReentrantLock则需要手动释放锁，不然可能会导致死锁现象。
- 是否可中断
  - synchronized不可中断
  - ReentrantLock可以中断，也可以不中断，中断的话要调用Interrupt
- 加锁是否公平
  - synchronized非公平锁
  - ReentrantLock两者都可以，默认公平锁。主要看构造方法的boolean值。
- 绑定多个condition
  - synchronized没有
  - ReentrantLock用来实现分组唤醒需要的线程们，可以精确唤醒，而不是像synchronized要么随机唤醒一个或者全部唤醒。

#### 什么是ThreadLocal?

- Thread 类有一个类型为 ThreadLocal.ThreadLocalMap 的实例变量 threadLocals，即每个线程都有一个属于自己的 ThreadLocalMap。
- ThreadLocalMap 内部维护着 Entry 数组，每个 Entry 代表一个完整的对象， key 是 ThreadLocal 本身，value 是 ThreadLocal 的泛型值。
- 每个线程在往 ThreadLocal 里设置值的时候，都是往自己的 ThreadLocalMap 里存，读也是以某个 ThreadLocal 作为引用，在自己的 map 里找对应的 key，从而实现了线程隔离。

#### 并发工具类？

1. CountDownLatch，它是一种计数器的方式保证线程同步；它不去控制多个子线程之间的前后关系，只保证某一线程能够在这些子线程执行完成后再执行。

```java
CountDownLatch countDownLatch = new CountDownLatch(2);
countDownLatch.countDown();
countDownLatch.await();
```

2. CyclicBarrier，通过设置屏障的方式使得多线程同步，能够控制多个线程在屏障处等等其他线程也执行到屏障点，可以实现CountDownLatch具有的功能，但是比CountDownLatch功能强大；

```java
CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -> {
            System.out.println("召唤神龙");
        });
cyclicBarrier.await();
```

3. Semaphore，信号量，用于控制访问某一公共资源的并发线程数；



## IO

#### 什么是IO流？

* java对数据的操作是通过流的方式，IO流用来处理设备之间的数据传输，上传文件和下载文件，Java用于操作流的对象都在IO包中。

#### io流分类

* 按流向分为：输入流，输出流

* 按类型分为：字节流字符流

#### NIO和传统IO有什么区别？

1. IO是面向流的，NIO是面向块（缓冲区）的。
1. IO是阻塞的，NIO是非阻塞的。

#### 说一说NIO的实现原理？

 NIO是基于IO多路复用模型的实现，它包含三个核心组件，分别是Buffer、Channel、Selector。

1.  NIO是面向缓冲区的，在NIO中所有的数据都是通过缓冲区处理的。Buffer就是缓冲区对象，无论读取还是写入，数据都是先进入Buffer的。Buffer的本质是一个数组，通常它是一个字节数组，也可以是其他类型的数组。Buffer是一个接口，它的实现类有ByteBuffer、CharBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer。
2.  Channel是一个通道，可以通过它读取和写入数据。与流不同的是，流是单向的，而Channel是双向的。数据可以通过Channel读到Buffer里，也可以通过Channel写入到Buffer里。为了支持不同的设备，Channel接口有好几种子类，如FileChannel用于访问磁盘文件、SocketChannel和ServerSocketChannel用于TCP协议的网络通信、DatagramChannel用于UDP协议的网络通信。
3.  Selector是多路复用器，可以通过它监听网络IO的状态。它可以不断轮询注册的Channel，如果某Channel上有连接、读取、写入事件发生，则这个Channel就处于就绪状态，就会被Selector轮询出来。所有被轮询出来的Channel集合，我们可以通过SelectionKey获取到，然后进行后续的IO操作。

#### BIO NIO AIO区别





## JVM

#### 类的加载过程？

类的加载过程一般分为三个阶段：加载、链接（验证、准备、解析）、初始化。

**加载：**

1. Java虚拟机将.class文件读入内存，并为之创建一个Class对象。

2. 任何类被使用时系统都会为其创建一个且仅有一个Class对象。

3. 这个Class对象描述了这个类创建出来的对象的所有信息，比如有哪些构造方法，都有哪些成员方法，都有哪些成员变量等。

**链接：**

1. 验证：确保.CLass文件字节流中包含的信息符合当前虚拟机的要求。不会危害的自身安全。Eg:这个类的父类是否继承了不允许被继承的类(被finaI修饰的类)

2. 准备：准备阶段正式为类变量分配内存以及为类变量设置初始值。注意：这时分配内存的仅仅包括类变量（被static修饰的变量）不包括实例变量，实例变量会再对象实例初始化时分配内存。这里所说的初始值“通常情况”下是数据类型的零值。

3. 解析：将方法区中的字符引用转换成直接引用

**初始化：**对静态的变量（static）进行赋值,包括初始化代码块。

#### 什么是双亲委派机制？

* 当某个类加载器需要加载某个 .class 文件时，它首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类。

* 双亲委派机制好处：

#### JVM内存？

JVM主要分为：程序计数器，Java虚拟机栈，本地方法栈，Java堆，方法区。

* **程序计数器**： 为了线程切换能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。计数器记录的是正在执行的虚拟机字节码指令的地址。
* **Java虚拟机栈**： 每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接（例如多态就要动态链接以确定引用的状态）、方法出口等信息。局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和 returnAddress 类型（指向了一条字节码指令的地址）。
  其中 64 位长度的 long 和 double 类型的数据会占用 2 个局部变量空间（Slot），其余的数据类型只占用 1 个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。
* **本地方法栈**： Java 虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。
* **Java 堆**： Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC 堆”。
* **方法区**： 方法区（Method Area）与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量（final ）、静态变量（static）、即时编译器编译后的代码等数据。

#### Java内存模型？

* Java Memory Model (JAVA 内存模型，JMM）描述线程之间如何通过内存(memory)来进行交互。实际上是一个虚拟的概念

* JVM中存在一个主存区（Main Memory或Java Heap Memory），对于所有线程进行共享，而每个线程又有自己的工作内存，工作内存中保存的是主存中某些变量的拷贝。

* 线程对所有变量的操作并非发生在主存区，而是发生在工作内存中，而线程之间是不能直接相互访问的，变量在程序中的传递，是依赖主存来完成的

## 垃圾回收

#### 堆内存垃圾回收过程

1. `新生成`的对象首先放到`Eden`区，当Eden区`满了`会触发`Minor GC`。

2. 第一步GC活下来的对象，会被移动到`survivor`区中的S0区，S0区满了之后会触发`Minor GC`，S0区存活下来的对象会被移动到S1区，S0区空闲。S1满了之后在GC，存活下来的再次移动到S0区，S1区空闲，这样反反复复GC，每GC一次，对象的年龄就`涨一岁`，达到某个值后（15），就会进入`老年代`。

3. 在发生一次`Minor GC`后（前提条件），老年代可能会出现`Major GC`，这个视垃圾回收器而定。

#### Java垃圾回收机制？

垃圾回收算法：

标记清除

* 标记清除算法是一种先标记，后清除的算法，在第一次扫描的时候先标记出所有需要清理的内存，将所有需要回收的内存都标记过后，一次性清理掉
* 这种算法简单但是效率低，而且内存碎片化严重。内存一旦碎片化严重的话，就会浪费内存，无法分配较大的对象。

标记整理：

* 既然标记清除和复制算法各有优缺点，那自然的我们就想到是否可以把这两种算法结合起来，于是就出现了标记整理算法。标记阶段是标记清除算法一样，先标记出需要回收的部分，不过清除阶段不是直接清除，而是把存活的对象往内存的一端进行移动，然后清除剩下的部分。
* 标记整理的算法虽然可以解决上面两个算法的一些问题，但是还是需要先进行标记，然后进行移动，整个效率还是偏低的。

复制算法：

* 复制算法的实现方式比较简洁明了，就是霸道的把内存分成两部分，在平时使用的时候只用其中的固定一份，在当需要进行 GC 的时候，把存活的对象复制到另一部分中，然后将已经使用的内存全部清理掉。
* 这种算法可以解决碎片化的问题，但是缺点也很明显，就是浪费内存，有一半的内存都不能使用。

年轻代复制算法，年老代使用标记整理法。

#### 垃圾回收器？

1. Serial 单线程新生代复制算法的垃圾回收器；
2. SerialOld 垃圾回收器，是一种单线程老年代标记整理算法；
3. ParNew 垃圾回收器，是 Serial 的多线程实现，采用复制算法实现；
4. Parallel Scavenge 垃圾回收器，是一种高效的多线程复制算法；
5. ParallelOld 垃圾回收器，是 Parallel Scavenge 的一种老年代的多线程标记整理算法；
6. CMS 垃圾回收器，是一种多线程标记清除算法，后面会详细介绍；
7. G1 垃圾回收器，是一种高吞吐量的垃圾回收器。

#### 如何判断对象不在使用？

* 引用计数算法
  * 给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。JVM里面并没有选用引用计数算法来管理内存，主要原因是它很难解决对象之间相互循环引用的问题。

* 可达性分析算法
  * 通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。

#### 在java语言中，什么对象可作为GCRoot的对象？

    a. java虚拟机栈中的引用的对象。 
    
    b.方法区中的类静态属性引用的对象。 （一般指被static修饰的对象，加载类的时候就加载到内存中。）
    
    c.方法区中的常量引用的对象。 
    
    d.本地方法栈中的JNI（native方法）引用的对象

#### 哈希表作用？

* **哈希表（Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构。**也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。



## 设计模式

#### 什么是设计模式？

设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计 模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。

#### 设计模式原则：

**开放封闭原则（Open Close Principle）**

- 原则思想：尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化 
- 描述：一个软件产品在生命周期内，都会发生变化，既然变化是一个既定的事实，我们就应该在设 计的时候尽量适应这些变化，以提高项目的稳定性和灵活性。
- 优点：单一原则告诉我们，每个类都有自己负责的职责，里氏替换原则不能破坏继承关系的体系。

**里氏代换原则（Liskov Substitution Principle）**

- 原则思想：使用的基类可以在任何地方使用继承的子类，完美的替换基类。
- 大概意思是：子类可以扩展父类的功能，但不能改变父类原有的功能。子类可以实现父类的抽象方 法，但不能覆盖父类的非抽象方法，子类中可以增加自己特有的方法。
- 优点：增加程序的健壮性，即使增加了子类，原有的子类还可以继续运行，互不影响。

**依赖倒转原则（Dependence Inversion Principle）**

- 依赖倒置原则的核心思想是面向接口编程
- 依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类
- 这个是开放封闭原则的基础，具体内容是：对接口编程，依赖于抽象而不依赖于具体。

**接口隔离原则（Interface Segregation Principle）**

* 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的 意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级 和维护方便。所以上文中多次出现：降低依赖，降低耦合
* 例如：支付类的接口和订单类的接口，需要把这俩个类别的接口变成俩个隔离的接口

**迪米特法则（最少知道原则）（Demeter Principle）**

* 原则思想：一个对象应当对其他对象有尽可能少地了解，简称类间解耦
* 大概意思就是一个类尽量减少自己对其他对象的依赖，原则是低耦合，高内聚，只有使各个模块之 间的耦合尽量的低，才能提高代码的复用率。
* 优点：低耦合，高内聚。

**单一职责原则（Principle of single responsibility）**

* 原则思想：一个方法只负责一件事情。
* 描述：单一职责原则很简单，一个方法 一个类只负责一个职责，各个职责的程序改动，不影响其 它程序。 这是常识，几乎所有程序员都会遵循这个原则。
* 优点：降低类和类的耦合，提高可读性，增加可维护性和可拓展性，降低可变性的风险。

#### 单例模式

保证一个类只有一个实例，并且提供一个访问该全局访问点

用处：

1. 网站的计数器，一般也是采用单例模式实现，否则难以同步。 
2. 应用程序的日志应用，一般都是单例模式实现，只有一个实例去操作才好，否则内容不好追加显 示。 
3. 多线程的线程池的设计一般也是采用单例模式，因为线程池要方便对池中的线程进行控
4. Windows的（任务管理器）就是很典型的单例模式，他不能打开俩个 
5. windows的（回收站）也是典型的单例应用。在整个系统运行过程中，回收站只维护一个实例。

优点： 

* 由于在系统内存中只存在一个对象，因此可以节约系统资源，当需要频繁创建和销毁的对象时单例 模式无疑可以提高系统的性
* 提供了对唯一实例的受控访问。
* 在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例。这 样就防止其它对象对自己的实例化，确保所有的对象都访问一个实例

缺点：

* 不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据 的错误，不能保存彼此的状态。
* 不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据 的错误，不能保存彼此的状态。
* 由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。

单例模式分类:

饿汉式，饱汉式，双重加锁式。

#### 工厂模式

我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。实现了创建者和调用者分离。

**简单工厂**：

* 简单工厂模式相当于是一个工厂中有各种产品，创建在一个类中，客户无需知道具体产品的名称,只需要知道产品类所对应的参数即可。但是工厂的职责过重，而且当类型过多时不利于系统的扩展
  维护。 

**工厂方法：**

* 在工厂方法模式中，核心的工厂类不再负责所有的产品的创建，而是将具体创建的工作交给子类去做。该核心类成为一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。

**抽象工厂：**

* 抽象工厂简单地说是工厂的工厂，抽象工厂可以创建具体工厂，由具体工厂来产生具体产品。

**应用**

* 在Spring IOC容器创建bean的过程是使用了工厂设计模式 beanFactory
* LoggerFactory
* ThreadFacotry

#### 代理模式

* 通过代理控制对象的访问，可以在这个对象调用方法之前、调用方法之后去处理/添加新的功能。 

* 应用：Spring AOP、日志打印、异常处理、事务控制、权限控制

#### 策略模式

* 定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。

#### 构造者模式

* 是将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的方式进行创建。 

#### 观察者模式

* 观察者模式（Observer Pattern）也称发布订阅模式，它的目的是定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。

#### 适配器模式

* 适配器的目的是将一个类的接口变换成客户端所期待的另一种接口，就是可以将一个对象包装成另外的一个接口。

#### 装饰者模式

* 装饰器的目的是动态地给一个对象添加一些额外的职责，这个对象的类型不会发生变化，但是行为却发生了改变。

#### Spring框架在实现时运用了大量的设计模式，常见的有如下几种：

1. 简单工厂

   Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得Bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。

2. 工厂方法

   实现了FactoryBean接口的bean是一类叫做factory的bean。其特点是，spring会在使用getBean()调用获得该bean时，会自动调用该bean的getObject()方法，所以返回的不是factory这个bean，而是这个bean的getOjbect()方法的返回值。

3. 单例模式

   Spring依赖注入Bean实例默认是单例的。Spring的依赖注入（包括lazy-init方式）都是发生在AbstractBeanFactory的getBean里。getBean的doGetBean方法调用getSingleton进行bean的创建。

4. 适配器模式

   SpringMVC中的适配器HandlerAdatper，它会根据Handler规则执行不同的Handler。即DispatcherServlet根据HandlerMapping返回的handler，向HandlerAdatper发起请求处理Handler。HandlerAdapter根据规则找到对应的Handler并让其执行，执行完毕后Handler会向HandlerAdapter返回一个ModelAndView，最后由HandlerAdapter向DispatchServelet返回一个ModelAndView。

5. 装饰器模式

   Spring中用到的装饰器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。

6. 代理模式

   AOP底层就是动态代理模式的实现。即：切面在应用运行的时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象创建动态的创建一个代理对象。SpringAOP就是以这种方式织入切面的。

7. 观察者模式

   Spring的事件驱动模型使用的是观察者模式，Spring中Observer模式常用的地方是listener的实现。

8. 策略模式

   Spring框架的资源访问Resource接口。该接口提供了更强的资源访问能力，Spring 框架本身大量使用了 Resource 接口来访问底层资源。Resource 接口是具体资源访问策略的抽象，也是所有资源访问类所实现的接口。

9. 模板方法模式

   Spring模板方法模式的实质，是模板方法模式和回调模式的结合，是Template Method不需要继承的另一种实现方式。Spring几乎所有的外接扩展都采用这种模式。

#### 项目中那些地方用到了设计模式？

* 单例模式：
  1. 网站的计数器，一般也是采用单例模式实现，否则难以同步。 
  2. 应用程序的日志应用，一般都是单例模式实现，只有一个实例去操作才好，否则内容不好追加显示。 

* 建造者模式：比如在构建user时设置大量属性就用不着写大量的set。

* 模板方法模式 , 也就是钩子函数 ;比如你有一个业务 , 逻辑都是第一步干什么第二步干什么一直到最后一步 , 像一个模板一样 , 但是根据不同的情况某些步骤要做不同的处理 , 你就可以在父类写下流程 , 将不同的处理部分写成待完成的方法留给子类实现 ;



## 数据库

#### 主键、外键和索引的区别？

* 主键：唯一标识一条记录，不能有重复的，不允许为空 

* 外键：表的外键是另一表的主键, 外键可以有重复的, 可以是空值 

* 索引：该字段没有重复值，但可以有一个空值

作用：

* 主键：用来保证数据完整性

* 外键：用来和其他表建立联系用的 

* 索引：是提高查询排序的速度 

个数： 

* 主键只能有一个 外

* 一个表可以有多个外键 

* 一个表可以有多个唯一索引

#### MyISAM和InnoDB有什么区别？

MyISAM：  

1. 不支持事务，但是每次查询都是原子的； 
2. 支持表级锁，即每次操作是对整个表加锁；
3. 存储表的总行数； 
4. 一个 MYISAM 表有三个文件：索引文件、表结构文件、数据文件； 
5. 采用非聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引 基本一致，但是辅索引不用保证唯一性。 

InnoDb：

1.  支持 ACID 的事务，支持事务的四种隔离级别； 
2.  支持行级锁及外键约束：因此可以支持写并发；
3.  不存储总行数： 
4.  一个 InnoDb 引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制， 一个表可能分布在多个文件里），也有可能为多个（设置为独立表空，表大小受 操作系统文件大小限制，一般为 2G），受操作系统文件大小的限制； 
5.  主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅 索引；最好使用自增主键，防止插入数据时，为维持 B+树结构，文件的大调整

#### 关于两种引擎锁的机制？



#### 项目设计分库分表，如何通过技术保持数据的一致性？



#### 什么是索引？

* 索引是一种特殊的文件(InnoDB 数据表上的索引是表空间的一个组成部分)，包含着对数据表里所有记录的引用指针。

* 索引可以极大的提高数据的查询速度，但是会降低插入、删除、更新表的速度， 因为在执行这些写操作时，还要操作索引文件。

#### 索引的分类

**常见的索引类型有：主键索引、唯一索引、普通索引、全文索引、组合索引**

* 主键索引：即主索引，根据主键pk_clolum（length）建立索引，不允许重复，不允许空值；

```sql 
ALTER TABLE 'table_name' ADD PRIMARY KEY pk_index('col')；
```

* 唯一索引：用来建立索引的列的值必须是唯一的，允许空值

```plain
ALTER TABLE 'table_name' ADD UNIQUE index_name('col')；
```

* 普通索引：用表中的普通列构建的索引，没有任何限制

```plain
ALTER TABLE 'table_name' ADD INDEX index_name('col')；
```

* 全文索引：用大文本对象的列构建的索引（下一部分会讲解）

```plain
ALTER TABLE 'table_name' ADD FULLTEXT INDEX ft_index('col')；
```

* 组合索引：用多个列组合构建的索引，这多个列中的值不允许有空值

```plain
ALTER TABLE 'table_name' ADD INDEX index_name('col1','col2','col3')；
```

* 遵循“最左前缀”原则，把最常用作为检索或排序的列放在最左，依次递减，组合索引相当于建立了col1, col1col2, col1col2col3三个索引，而col2或者col3是不能使用索引的。

#### 索引的原理？

* B+树，经过优化的 B+树 

* 主要是在所有的叶子结点中增加了指向下一个叶子节点的指针，因此 InnoDB 建 议为大部分表使用默认自增的主键作为主索引。

#### 索引失效的情况？

- 查询条件包含 or，可能导致索引失效
- 字段类型是字符串，where 时一定用引号括起来，否则索引失效
- like 通配符可能导致索引失效。
- 联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。
- 在索引列上使用 mysql 的内置函数，索引失效。
- 对索引列运算(如，+、-、*、/)，索引失效。
- 索引字段上使用(!= 或者 < >，not in)时，可能会导致索引失效。
- 索引字段上使用 is null， is not null，可能导致索引失效。

#### 聚簇索引和非聚簇索引的区别？

- **聚簇索引：**将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据
- **非聚簇索引：**将数据与索引分开存储，索引结构的叶子节点指向了数据对应的位置

#### 视图和表的区别

* 视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改， 查，操作，视图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。
* 基本表是本身独立存在的表，在 SQL 中一个关系就对应一个表。 视图是从 一个或几个基本表导出的表。视图本身不独立存储在数据库中，是一个虚表

#### 什么存储过程？

* 存储过程是一个预编译的 SQL 语句，优点是允许模块化的设计，就是说只需 创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次 SQL， 使用存储过程比单纯 SQL 语句执行要快。可以用一个命令对象来调用存储过程。

#### 什么是事务？

* 事务（transaction）是作为一个单元的一组有序的数据库操作。如果组中的所有操作都成功，则认为事务成功，即使只有一个操作失败，事务也不成功。如果所有操作完成，事务则提交，其修改将作用于所有其他数据库进程。如果一个操作失败，则事务将回滚，该事务所有操作的影响都将取消。

#### 事务特性？

1. 原子性：即不可分割性，事务要么全部被执行，要么就全部不被执行。 
2. 一致性或可串性。事务的执行使得数据库从一种正确状态转换成另一种正确状态 
3. 隔离性。在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务
4. 持久性。事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后 有了其他故障，事务的处理结果也会得到保存.

#### 事务的隔离级别？

* 读未提交：就是一个事务可以读取另一个未提交事务的数据。

* 读已提交：就是一个事务要等另一个事务提交后才能读取数据。

* 可重复读：就是在开始读取数据（事务开启）时，不再允许修改操作

* 串行化：是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。

#### Mysql默认的隔离级别？

* 可重复读

#### 什么是脏读、不可重复读、幻读？

- 脏读（Dirty Read）：A 事务读取 B 事务尚未提交的数据并在此基础上操作，而B事务执行回滚，那么A读取到的数据就是脏数据。
- 不可重复读（Unrepeatable Read）：事务 A 重新读取前面读取过的数据，发现 该数据已经被另一个已提交的事务 B 修改过了。
- 幻读（Phantom Read）：事务 A 重新执行一个查询，返回一系列符合查询条件的行，发现其中插入了被事务 B 提交的行。

#### 三个范式?

1. 第一范式：1NF 是对属性的原子性约束，要求属性具有原子性，不可再分解； 
2. 第二范式：2NF 是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性； 
3. 第三范式：3NF 是对字段冗余性的约束，即任何字段不能由其他字段派生出来， 它要求字段没有冗余。

#### 表锁？

* 开销小，加锁快；
* 不会出现死锁；
* 锁定粒度大，发生锁冲突的概率最高，并发度最低。

#### 行锁？

* 开销大，加锁慢；
* 会出现死锁；
* 锁定粒度最小，发生锁冲突的概率最 低，并发度也最高。

#### 内连接外连接区别？

* 内连接：也称为等值连接，将一 个表的所有记录和另一个表中的所有记录一一匹配。返回两张表都满足条件的部分，不满足的丢弃。

* 外连接：不仅包含符合连接条件的行，而且还包含左表（左外连接）、右表（右外连接）或两个边接表（全外连接）中的所有数据行。

#### 左连接与右连接区别？

* 左连接：取左边的表的全部，右边的表按条件，符合的显示，不符合则显示null

* 右连接：取右边的表的全部，左边的表按条件，符合的显示，不符合则显示null

#### 你是如何设计数据库？

1. 了解功能需求 ，产品需求规格说明书，与项目相关人员（比如项目经理、客户等）进行充分沟通。
2. 定义实体 ，通过分析系统功能定义出系统有哪些实体
3. 绘制E-R图，根据实体以及实体之间的关系绘制出E-R图
4. 把E-R图转换成模型，构建物理模型可以使用一些工具，比如目前比较流行的PowerDesigner
5. 检查模型 检查模型是否满足第三范式的要求
6. 根据模型定义数据库

#### sql优化经验？

* 加索引
* 避免返回不必要的数据

-  适当分批量进行
-  优化 sql 结构
-  分库分表
-  读写分离

#### 什么是回表？

* 回表就是先通过数据库索引扫描出数据所在的行，再通过行主键id取出索引中未提供的数据，即基于非主键索引的查询需要多扫描一棵索引树.

#### SQL语句执行顺序？

1. from
2. join
3. on
4. where
5. group by (可以使用 select 中的别名，后面的语句中都可以使用)
6. count、sum、svg…
7. having
8. select
9. distinct
10. order by
11. limit

例如：

```sql
select * from tb_user where size > 1 group by name order by age;
// 执行顺序 where、group、 select、 order
```

## Redis

#### 什么是 Redis？

* Redis 是完全开源免费的，遵守 BSD 协议，是一个高性能的 key-value 数据库。

* Redis 与其他 key - value 缓存产品有以下三个特点：
  1. Redis 支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 
  2. Redis 不仅仅支持简单的 key-value 类型的数据，同时还提供 list，set，zset， hash 等数据结构的存储。
  3. Redis 支持数据的备份，即 master-slave 模式的数据备份。

#### Redis 优势？

1. 性能极高 – Redis 能读的速度是 110000 次/s,写的速度是 81000 次/s 。
2. 丰富的数据类型 – Redis 支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。 
3. 原子 – Redis 的所有操作都是原子性的，意思就是要么成功执行要么失败完全不 执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过 MULTI 和 EXEC 指令包起来。 
4. 丰富的特性 – Redis 还支持 publish/subscribe, 通知, key 过期等等特性

#### redis数据类型以及使用场景

* string 
* list 
  * 消息队列
* set 
* zset
  * 排序榜
*  hash

#### Redis的常用应用场景

- 缓存
- 排行榜 zset
- 计数器应用
- 共享 Session
- 分布式锁 
- 社交网络 
- 消息队列 
- 位操作

#### 过期删除策略

* 定时删除: 在设置键的过期时间的同时，创建一个定时器 timer.让定时器在键 的过期时间来临时，立即执行对键的删除操作。

* 惰性删除: 放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是 否过期，如果过期的话，就删除该键;如果没有过期，就返回该键。

* 定期删除: 每隔一段时间程序就对数据库进行一次检查，删除里面的过期键。至 于要删除多少过期键，以及要检查多少个数据库，则由算法决定。

#### 缓存淘汰策略：

- FIFO (先进先出)
- LRU (最近最少使用)
- LFU (最不经常使用)

#### redis持久化机制？

RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘

优点：

只有一个文件 dump.rdb，方便持久化

性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能

相对于数据集大时，比 AOF 的启动效率更高。

缺点：

数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生 故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)

AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。

优点：

数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。

缺点：

AOF 文件比 RDB 文件大，且恢复速度慢。 

数据集大的时候，比 rdb 启动效率低。



#### Redis的缓存淘汰机制是什么？

1. volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最 少使用的数据淘汰 
2. volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过 期的数据淘汰
3. volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意 选择数据淘汰
4. allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰 
5. allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰 
6. no-enviction（驱逐）：禁止驱逐数据

注意这里的 6 种机制，volatile 和 allkeys 规定了是对已设置过期时间的数据集淘 汰数据还是从全部数据集淘汰数据，后面的 lru、ttl 以及 random 是三种不同的 淘汰策略，再加上一种 no-enviction 永不回收的策略。

使用策略规则：

1. 如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率 低，则使用 allkeys-lru 
2. 如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用 allkeys-random.

#### 是否使用过 Redis 集群，集群的原理是什么？

1. Redis Sentinal 着眼于高可用，在 master 宕机时会自动将 slave 提升为 master，继续提供服务。
2. Redis Cluster 着眼于扩展性，在单个 redis 内存不足时，使用 Cluster 进行分片存储。

#### 缓存穿透 击穿 雪崩？

缓存穿透：查询缓存和数据库中都没有的数据

解决：

1. 在接口层增加校验
2. 从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击

缓存击穿：去查询缓存中没有但数据库中有的数据（一般是缓存时间到期）

解决：

1. 设置热点数据永远不过期。
2. 加互斥锁，互斥锁参

缓存雪崩：是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是， 缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。

1. 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
2. 如果缓存数据库是分布式部署，将热点数据均匀分布在不同得缓存数据库中。
3. 设置热点数据永远不过期。

#### 并发环境如何保证缓存数据库一致?

- 缓存延时双删
- 删除缓存重试机制
- 读取 biglog 异步删除缓存

## Mybatis框架

#### 什么是 Mybatis？

1. Mybatis 是一个半 ORM（对象关系映射）框架，它内部封装了 JDBC，开发时 只需要关注 SQL 语句本身，不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。程序员直接编写原生态 sql，可以严格控制 sql 执行性 能，灵活度高。
2. MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO 映射成数 据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。
3. 通过 xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过 java 对象和 statement 中 sql 的动态参数进行映射生成最终执行的 sql 语句，最 后由 mybatis 框架执行 sql 并将结果映射为 java 对象并返回。（从执行 sql 到返 回 result 的过程）。

#### Mybatis缓存？

1. 一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就 将清空，默认打开一级缓存。
2. 二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源， 如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要 实现 Serializable 序列化接口(可用来保存对象的状态),可在它的映射文件中配置 ；
3. 对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存 Namespaces)的进行了 C/U/D 操作后，默认该作用域下所有 select 中的缓存将 被 clear。

#### \#{}和${}的区别是什么？

1. \#{}是预编译处理，${}是字符串替换。
2. Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 的 set 方法来赋值；
3. Mybatis 在处理${}时，就是把${}替换成变量的值。 
4. 使用#{}可以有效的防止 SQL 注入，提高系统安全性。

#### 谈谈MyBatis和JPA的区别

**参考答案**

ORM映射不同：

MyBatis是半自动的ORM框架，提供数据库与结果集的映射；

JPA（默认采用Hibernate实现）是全自动的ORM框架，提供对象与数据库的映射。

可移植性不同：

JPA通过它强大的映射结构和HQL语言，大大降低了对象与数据库的耦合性；

MyBatis由于需要写SQL，因此与数据库的耦合性直接取决于SQL的写法，如果SQL不具备通用性而用了很多数据库的特性SQL的话，移植性就会降低很多，移植时成本很高。

日志系统的完整性不同：

JPA日志系统非常健全、涉及广泛，包括：SQL记录、关系异常、优化警告、缓存提示、脏数据警告等；

MyBatis除了基本的记录功能外，日志功能薄弱很多。

SQL优化上的区别：

由于Mybatis的SQL都是写在XML里，因此优化SQL比Hibernate方便很多。

而Hibernate的SQL很多都是自动生成的，无法直接维护SQL。虽有HQL，但功能还是不及SQL强大，见到报表等复杂需求时HQL就无能为力，也就是说HQL是有局限的Hhibernate虽然也支持原生SQL，但开发模式上却与ORM不同，需要转换思维，因此使用上不是非常方便。总之写SQL的灵活度上Hibernate不及Mybatis。

#### MyBatis输入输出支持的类型有哪些？

**参考答案**

parameterType：

MyBatis支持多种输入输出类型，包括：

1. 简单的类型，如整数、小数、字符串等；
2. 集合类型，如Map等；
3. 自定义的JavaBean。

其中，简单的类型，其数值直接映射到参数上。对于Map或JavaBean则将其属性按照名称映射到参数上。

#### MyBatis里如何实现一对多关联查询？

**参考答案**

一对多映射有两种配置方式，都是使用collection标签实现的。在此之前，为了能够存储一对多的数据，需要在主表对应的实体类中增加集合属性，用于封装子表对应的实体类。

嵌套查询：

1. 通过select标签定义查询主表的SQL，返回结果通过reusltMap进行映射。
2. 在resultMap中，除了映射主表属性，还要通过collection标签映射子表属性，该标签需包含如下内容：
   - 通过property属性指定子表属性名；
   - 通过javaType属性指定封装子表属性的集合类型；
   - 通过ofType属性指定子表的实体类型；
   - 通过select属性指定查询子表所依赖的SQL，这个SQL需单独定义，内部包含查询子表的语句。

嵌套结果：

1. 通过select标签定义关联查询主表和子表的SQL，返回结果通过resultMap进行映射。
2. 在resultMap中，除了映射主表属性，还要通过collection标签映射子表属性，该标签需包含如下内容：
   - 通过property属性指定子表属性名；
   - 通过ofType属性指定子表的实体类型；
   - 通过result子标签定义子表字段和属性的映射关系。

#### MyBatis中的$和#有什么区别？

**参考答案**

使用#设置参数时，MyBatis会创建预编译的SQL语句，然后在执行SQL时MyBatis会为预编译SQL中的占位符（?）赋值。预编译的SQL语句执行效率高，并且可以防止注入攻击。

使用$设置参数时，MyBatis只是创建普通的SQL语句，然后在执行SQL语句时MyBatis将参数直接拼入到SQL里。这种方式在效率、安全性上均不如前者，但是可以解决一些特殊情况下的问题。例如，在一些动态表格（根据不同的条件产生不同的动态列）中，我们要传递SQL的列名，根据某些列进行排序，或者传递列名给SQL都是比较常见的场景，这就无法使用预编译的方式了。

#### 既然$不安全，为什么还需要$，什么时候会用到它？

**参考答案**

它可以解决一些特殊情况下的问题。例如，在一些动态表格（根据不同的条件产生不同的动态列）中，我们要传递SQL的列名，根据某些列进行排序，或者传递列名给SQL都是比较常见的场景，这就无法使用预编译的方式了。

#### MyBatis的xml文件和Mapper接口是怎么绑定的？

**参考答案**

是通过xml文件中，<mapper> 根标签的namespace属性进行绑定的，即namespace属性的值需要配置成接口的全限定名称，MyBatis内部就会通过这个值将这个接口与这个xml关联起来。

#### MyBatis分页和自己写的分页哪个效率高？

**参考答案**

自己写的分页效率高。

在MyBatis中，我们可以通过分页插件实现分页，也可以通过分页SQL自己实现分页。其中，分页插件的原理是，拦截查询SQL，在这个SQL基础上自动为其添加limit分页条件。它会大大的提高开发的效率，但是无法对分页语句做出有针对性的优化，比如分页偏移量很大的情况，而这些在自己写的分页SQL里却是可以灵活实现的。

#### 了解MyBatis缓存机制吗？

**参考答案**

MyBatis的缓存分为一级缓存和二级缓存。

一级缓存：

一级缓存也叫本地缓存，它默认会启用，并且不能关闭。一级缓存存在于SqlSession的生命周期中，即它是SqlSession级别的缓存。在同一个 SqlSession 中查询时，MyBatis 会把执行的方法和参数通过算法生成缓存的键值，将键值和查询结果存入一个Map对象中。如果同一个SqlSession 中执行的方法和参数完全一致，那么通过算法会生成相同的键值，当Map 缓存对象中己经存在该键值时，则会返回缓存中的对象。

二级缓存：

二级缓存存在于SqlSessionFactory 的生命周期中，即它是SqlSessionFactory级别的缓存。若想使用二级缓存，需要在如下两处进行配置。

在MyBatis 的全局配置settings 中有一个参数cacheEnabled，这个参数是二级缓存的全局开关，默认值是true ，初始状态为启用状态。

MyBatis 的二级缓存是和命名空间绑定的，即二级缓存需要配置在Mapper.xml 映射文件中。在保证二级缓存的全局配置开启的情况下，给Mapper.xml 开启二级缓存只需要在Mapper. xml 中添加如下代码：



二级缓存具有如下效果：

- 映射语句文件中的所有SELECT 语句将会被缓存。
- 映射语句文件中的所有时INSERT 、UPDATE 、DELETE 语句会刷新缓存。
- 缓存会使用Least Rece ntly U sed ( LRU ，最近最少使用的）算法来收回。
- 根据时间表（如no Flush Int erv al ，没有刷新间隔），缓存不会以任何时间顺序来刷新。
- 缓存会存储集合或对象（无论查询方法返回什么类型的值）的1024 个引用。
- 缓存会被视为read/write（可读／可写）的，意味着对象检索不是共享的，而且可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。

#### Mybatis 是如何进行分页的?分页插件的原理是什么?

Mybatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内 存分页，而非物理分页。可以在 sql 内直接书写带有物理分页的参数来完成物理分 页功能，也可以使用分页插件来完成物理分页。

分页插件的基本原理是使用 Mybatis 提供的插件接口，实现自定义插件，在插件 的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物 理分页语句和物理分页参数。

## 消息队列

#### 什么是消息队列

你可以把消息队列理解为一个**使用队列来通信**的组件。它的本质，就是个**转发器**，包含**发消息、存消息、消费消息**的过程。最简单的消息队列模型如下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpyvQAZ3eSuN9XibLK4hDzyjZXia000yHwcrHRuBWJkhDaIYnL9QPC0hNk3Kor0vJCVVLKUKYvNbf7FA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

我们通常说的消息队列，简称**MQ（Message Queue）**，它其实就指**消息中间件**，当前业界比较流行的开源消息中间件包括：`RabbitMQ、RocketMQ、Kafka`。

#### 消息队列的应用场景

1. 应用解耦
2. 流量削峰
3. 异步处理
4. 消息通讯
5. 远程调用

#### 消息队列如何解决消息丢失问题



#### 消息队列如何保证消息的顺序性。



## Spring

#### 谈谈你对spring的理解？

Spring 是个 java 企业级应用的开源开发框架。Spring 主要用来开发 Java 应用， 但是有些扩展是针对构建 J2EE 平台的 web 应用。Spring 框架目标是简化 Java 企业级应用开发，并通过 POJO 为基础的编程模型促进良好的编程习惯。

#### 什么是 spring bean？

- 它们是构成用户应用程序主干的对象
- Bean 由 Spring IoC 容器管理。
- 它们由 Spring IoC 容器实例化，配置，装配和管理。
- Bean 是基于用户提供给容器的配置元数据创建。

#### springbean的生命周期是什么样？

1. Spring 容器根据配置中的 bean 定义中实例化 bean。
2. Spring 使用依赖注入填充所有属性，如 bean 中所定义的配置。
3. 如果 bean 实现 BeanNameAware 接口，则工厂通过传递 bean 的 ID 来调用 setBeanName()。
4. 如果 bean 实现 BeanFactoryAware 接口，工厂通过传 递自身的实例来调用 setBeanFactory()。
5. 如果存在与 bean 关联的任何 BeanPostProcessors，则调用 preProcessBeforeInitialization() 方法。
6. 如 果为 bean 指定了 init 方法（  的 init-method 属性），那么将调 用它。
7. 最后，如果存在与 bean 关联的任何 BeanPostProcessors，则将调用 postProcessAfterInitialization() 方法。
8. 如果 bean 实现 DisposableBean 接口，当 spring 容器关闭时，会调用 destory()。
9. 如果为 bean 指定了 destroy 方法（  的 destroy-method 属性），那么将 调用它。

#### 你认为spring是线程安全的吗？

不，Spring 框架中的单例 bean 不是线程安全的。

#### 什么是Spring的IOC?

Spring 框架的核心是 Spring 容器。容器创建对象，将它们装配在一起，配置它们并管理它们的完整生命周期。Spring 容器使用依赖注入来管理组成应用程序的组件。容器通过读取提供的配置元数据来接收对象进行实例化，配置和组装的指令。该元数据可以通过 XML，Java 注解或 Java 代码提供。

在依赖注入中，您不必创建对象，但必须描述如何创建它们。您不是直接在代码中将组件和服务连接在一起，而是描述配置文件中哪些组件需要哪些服务。由 IoC 容器将它们装配在一起。

#### 什么是Spring中的控制反转？

#### IOC底层技术用什么实现的？

Spring 中的 IoC 的实现原理就是工厂模式加反射机制。

#### 控制反转的底层用什么实现的？这样设计对spring框架有什么好处？

#### Spring AOP的理解？

- AOP是一种编程思想，是通过预编译方式和运行期动态代理的方式，在不修改源代码的情况下实现给程序动态统一添加功能的技术。面向对象编程将程序抽象成各个层次的对象，而面向切面编程是将程序抽象成各个切面。所谓切面，相当于应用对象间的横切点，我们可以将其单独抽象为单独的模块。

- AOP技术利用一种称为“横切”的技术，剖解开封装对象的内部，将影响多个类的公共行为封装到一个可重用的模块中，并将其命名为切面。所谓的切面，简单来说就是与业务无关，却为业务模块所共同调用的逻辑，将其封装起来便于减少系统的重复代码，降低模块的耦合度，有利用未来的可操作性和可维护性。

- 利用AOP可以对业务逻辑各个部分进行隔离，从而使业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高开发效率。

- AOP可以有多种实现方式，而Spring AOP支持如下两种实现方式。

  * JDK动态代理：这是Java提供的动态代理技术，可以在运行时创建接口的代理实例。Spring AOP默认采用这种方式，在接口的代理实例中织入代码。

  - CGLib动态代理：采用底层的字节码技术，在运行时创建子类代理的实例。当目标对象不存在接口时，Spring AOP就会采用这种方式，在子类实例中织入代码。

- 在应用场景方面，Spring AOP为IoC的使用提供了更多的便利。一方面，应用可以直接使用AOP的功能，设计应用的横切关注点，把跨越应用程序多个模块的功能抽象出来，并通过简单的AOP的使用，灵活地编制到模块中，比如可以通过AOP实现应用程序中的日志功能。另一方面，在Spring内部，例如事务处理之类的一些支持模块也是通过Spring AOP来实现的。

#### Spring框架在实现时运用了大量的设计模式，常见的有如下几种：

1. 简单工厂

   Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得Bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。

2. 工厂方法

   实现了FactoryBean接口的bean是一类叫做factory的bean。其特点是，spring会在使用getBean()调用获得该bean时，会自动调用该bean的getObject()方法，所以返回的不是factory这个bean，而是这个bean的getOjbect()方法的返回值。

3. 单例模式

   Spring依赖注入Bean实例默认是单例的。Spring的依赖注入（包括lazy-init方式）都是发生在AbstractBeanFactory的getBean里。getBean的doGetBean方法调用getSingleton进行bean的创建。

4. 适配器模式

   SpringMVC中的适配器HandlerAdatper，它会根据Handler规则执行不同的Handler。即DispatcherServlet根据HandlerMapping返回的handler，向HandlerAdatper发起请求处理Handler。HandlerAdapter根据规则找到对应的Handler并让其执行，执行完毕后Handler会向HandlerAdapter返回一个ModelAndView，最后由HandlerAdapter向DispatchServelet返回一个ModelAndView。

5. 装饰器模式

   Spring中用到的装饰器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。

6. 代理模式

   AOP底层就是动态代理模式的实现。即：切面在应用运行的时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象创建动态的创建一个代理对象。SpringAOP就是以这种方式织入切面的。

7. 观察者模式

   Spring的事件驱动模型使用的是观察者模式，Spring中Observer模式常用的地方是listener的实现。

8. 策略模式

   Spring框架的资源访问Resource接口。该接口提供了更强的资源访问能力，Spring 框架本身大量使用了 Resource 接口来访问底层资源。Resource 接口是具体资源访问策略的抽象，也是所有资源访问类所实现的接口。

9. 模板方法模式

   Spring模板方法模式的实质，是模板方法模式和回调模式的结合，是Template Method不需要继承的另一种实现方式。Spring几乎所有的外接扩展都采用这种模式。

#### Spring 事务中有哪几种事务传播行为?

- REQUIRED ：如果当前存在事务，则加入该事务。如果当前没有事务，则创建一个新的事务
- SUPPORTS：如果当前存在事务，则加入该事务 。如果当前没有事务， 则以非事务的方式继续运行
- MANDATORY  ：如果当前存在事务，则加入该事务 。如果当前没有事务，则抛出异常

不支持当前事务

- REQUIRES_NEW ：创建一个新事务，如果当前存在事务，则把当前事务挂起
- NOT_SUPPORTED ：以非事务方式运行，如果当前存在事务，则把当前事务挂起
- NEVER ：以非事务方式运行，如果当前存在事务，则抛出异常

其他情况

- NESTED ：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来执行 。如果当前没有事务，则该取值等价于REQUIRED

#### 请你说说Spring的核心是什么

**参考答案**

Spring框架包含众多模块，如Core、Testing、Data Access、Web Servlet等，其中Core是整个Spring框架的核心模块。Core模块提供了IoC容器、AOP功能、数据绑定、类型转换等一系列的基础功能，而这些功能以及其他模块的功能都是建立在IoC和AOP之上的，所以IoC和AOP是Spring框架的核心。

IoC（Inversion of Control）是控制反转的意思，这是一种面向对象编程的设计思想。在不采用这种思想的情况下，我们需要自己维护对象与对象之间的依赖关系，很容易造成对象之间的耦合度过高，在一个大型的项目中这十分的不利于代码的维护。IoC则可以解决这种问题，它可以帮我们维护对象与对象之间的依赖关系，降低对象之间的耦合度。

说到IoC就不得不说DI（Dependency Injection），DI是依赖注入的意思，它是IoC实现的实现方式，就是说IoC是通过DI来实现的。由于IoC这个词汇比较抽象而DI却更直观，所以很多时候我们就用DI来代替它，在很多时候我们简单地将IoC和DI划等号，这是一种习惯。而实现依赖注入的关键是IoC容器，它的本质就是一个工厂。

AOP（Aspect Oriented Programing）是面向切面编程思想，这种思想是对OOP的补充，它可以在OOP的基础上进一步提高编程的效率。简单来说，它可以统一解决一批组件的共性需求（如权限检查、记录日志、事务管理等）。在AOP思想下，我们可以将解决共性需求的代码独立出来，然后通过配置的方式，声明这些代码在什么地方、什么时机调用。当满足调用条件时，AOP会将该业务代码织入到我们指定的位置，从而统一解决了问题，又不需要修改这一批组件的代码。

#### 说一说你对Spring容器的了解

**参考答案**

Spring主要提供了两种类型的容器：BeanFactory和ApplicationContext。

- BeanFactory：是基础类型的IoC容器，提供完整的IoC服务支持。如果没有特殊指定，默认采用延 迟初始化策略。只有当客户端对象需要访问容器中的某个受管对象的时候，才对该受管对象进行初始化以及依赖注入操作。所以，相对来说，容器启动初期速度较快，所需要的资源有限。对于资源有限，并且功能要求不是很严格的场景，BeanFactory是比较合适的IoC容器选择。
- ApplicationContext：它是在BeanFactory的基础上构建的，是相对比较高级的容器实现，除了拥有BeanFactory的所有支持，ApplicationContext还提供了其他高级特性，比如事件发布、国际化信息支持等。ApplicationContext所管理的对象，在该类型容器启动之后，默认全部初始化并绑定完成。所以，相对于BeanFactory来说，ApplicationContext要求更多的系统资源，同时，因为在启动时就完成所有初始化，容 器启动时间较之BeanFactory也会长一些。在那些系统资源充足，并且要求更多功能的场景中，ApplicationContext类型的容器是比较合适的选择。

#### 说一说你对BeanFactory的了解

**参考答案**

BeanFactory是一个类工厂，与传统类工厂不同的是，BeanFactory是类的通用工厂，它可以创建并管理各种类的对象。这些可被创建和管理的对象本身没有什么特别之处，仅是一个POJO，Spring称这些被创建和管理的Java对象为Bean。并且，Spring中所说的Bean比JavaBean更为宽泛一些，所有可以被Spring容器实例化并管理的Java类都可以成为Bean。

BeanFactory是Spring容器的顶层接口，Spring为BeanFactory提供了多种实现，最常用的是XmlBeanFactory。但它在Spring 3.2中已被废弃，建议使用XmlBeanDefinitionReader、DefaultListableBeanFactory替代。BeanFactory最主要的方法就是 getBean(String beanName)，该方法从容器中返回特定名称的Bean。

#### 说一说你对Spring IOC的理解

**参考答案**

IoC（Inversion of Control）是控制反转的意思，这是一种面向对象编程的设计思想。在不采用这种思想的情况下，我们需要自己维护对象与对象之间的依赖关系，很容易造成对象之间的耦合度过高，在一个大型的项目中这十分的不利于代码的维护。IoC则可以解决这种问题，它可以帮我们维护对象与对象之间的依赖关系，降低对象之间的耦合度。

说到IoC就不得不说DI（Dependency Injection），DI是依赖注入的意思，它是IoC实现的实现方式，就是说IoC是通过DI来实现的。由于IoC这个词汇比较抽象而DI却更直观，所以很多时候我们就用DI来代替它，在很多时候我们简单地将IoC和DI划等号，这是一种习惯。而实现依赖注入的关键是IoC容器，它的本质就是一个工厂。

在具体的实现中，主要由三种注入方式：

1. 构造方法注入

   就是被注入对象可以在它的构造方法中声明依赖对象的参数列表，让外部知道它需要哪些依赖对象。然后，IoC Service Provider会检查被注入的对象的构造方法，取得它所需要的依赖对象列表，进而为其注入相应的对象。构造方法注入方式比较直观，对象被构造完成后，即进入就绪状态，可以马上使用。

2. setter方法注入

   通过setter方法，可以更改相应的对象属性。所以，当前对象只要为其依赖对象所对应的属性添加setter方法，就可以通过setter方法将相应的依赖对象设置到被注入对象中。setter方法注入虽不像构造方法注入那样，让对象构造完成后即可使用，但相对来说更宽松一些， 可以在对象构造完成后再注入。

3. 接口注入

   相对于前两种注入方式来说，接口注入没有那么简单明了。被注入对象如果想要IoC Service Provider为其注入依赖对象，就必须实现某个接口。这个接口提供一个方法，用来为其注入依赖对象。IoC Service Provider最终通过这些接口来了解应该为被注入对象注入什么依赖对象。相对于前两种依赖注入方式，接口注入比较死板和烦琐。

总体来说，构造方法注入和setter方法注入因为其侵入性较弱，且易于理解和使用，所以是现在使用最多的注入方式。而接口注入因为侵入性较强，近年来已经不流行了。

#### Spring是如何管理Bean的？

**参考答案**

Spring通过IoC容器来管理Bean，我们可以通过XML配置或者注解配置，来指导IoC容器对Bean的管理。因为注解配置比XML配置方便很多，所以现在大多时候会使用注解配置的方式。

以下是管理Bean时常用的一些注解：

1. @ComponentScan用于声明扫描策略，通过它的声明，容器就知道要扫描哪些包下带有声明的类，也可以知道哪些特定的类是被排除在外的。
2. @Component、@Repository、@Service、@Controller用于声明Bean，它们的作用一样，但是语义不同。@Component用于声明通用的Bean，@Repository用于声明DAO层的Bean，@Service用于声明业务层的Bean，@Controller用于声明视图层的控制器Bean，被这些注解声明的类就可以被容器扫描并创建。
3. @Autowired、@Qualifier用于注入Bean，即告诉容器应该为当前属性注入哪个Bean。其中，@Autowired是按照Bean的类型进行匹配的，如果这个属性的类型具有多个Bean，就可以通过@Qualifier指定Bean的名称，以消除歧义。
4. @Scope用于声明Bean的作用域，默认情况下Bean是单例的，即在整个容器中这个类型只有一个实例。可以通过@Scope注解指定prototype值将其声明为多例的，也可以将Bean声明为session级作用域、request级作用域等等，但最常用的还是默认的单例模式。
5. @PostConstruct、@PreDestroy用于声明Bean的生命周期。其中，被@PostConstruct修饰的方法将在Bean实例化后被调用，@PreDestroy修饰的方法将在容器销毁前被调用。

#### 介绍Bean的作用域

**参考答案**

默认情况下，Bean在Spring容器中是单例的，我们可以通过@Scope注解修改Bean的作用域。该注解有如下5个取值，它们代表了Bean的5种不同类型的作用域：

| 类型          | 说明                                                         |
| :------------ | :----------------------------------------------------------- |
| singleton     | 在Spring容器中仅存在一个实例，即Bean以单例的形式存在。       |
| prototype     | 每次调用getBean()时，都会执行new操作，返回一个新的实例。     |
| request       | 每次HTTP请求都会创建一个新的Bean。                           |
| session       | 同一个HTTP Session共享一个Bean，不同的HTTP Session使用不同的Bean。 |
| globalSession | 同一个全局的Session共享一个Bean，一般用于Portlet环境。       |

#### 说一说Bean的生命周期

**参考答案**

Spring容器管理Bean，涉及对Bean的创建、初始化、调用、销毁等一系列的流程，这个流程就是Bean的生命周期。整个流程参考下图：

![img](https://uploadfiles.nowcoder.com/images/20220224/4107856_1645694380479/7EF8F66C3DFA7434E4CA11B47CF8F1F7)

这个过程是由Spring容器自动管理的，其中有两个环节我们可以进行干预。

1. 我们可以自定义初始化方法，并在该方法前增加@PostConstruct注解，届时Spring容器将在调用SetBeanFactory方法之后调用该方法。
2. 我们可以自定义销毁方法，并在该方法前增加@PreDestroy注解，届时Spring容器将在自身销毁前，调用这个方法。

#### Spring是怎么解决循环依赖的？

**参考答案**

首先，需要明确的是spring对循环依赖的处理有三种情况：

1. 构造器的循环依赖：这种依赖spring是处理不了的，直接抛出BeanCurrentlylnCreationException异常。
2. 单例模式下的setter循环依赖：通过“三级缓存”处理循环依赖。
3. 非单例循环依赖：无法处理。

接下来，我们具体看看spring是如何处理第二种循环依赖的。

Spring单例对象的初始化大略分为三步：

1. createBeanInstance：实例化，其实也就是调用对象的构造方法实例化对象；
2. populateBean：填充属性，这一步主要是多bean的依赖属性进行填充；
3. initializeBean：调用spring xml中的init 方法。

从上面讲述的单例bean初始化步骤我们可以知道，循环依赖主要发生在第一步、第二步。也就是构造器循环依赖和field循环依赖。 Spring为了解决单例的循环依赖问题，使用了三级缓存。

```
/** Cache of singleton objects: bean name –> bean instance */ private final Map singletonObjects = new ConcurrentHashMap(256); /** Cache of singleton factories: bean name –> ObjectFactory */ private final Map> singletonFactories = new HashMap>(16); /** Cache of early singleton objects: bean name –> bean instance */ private final Map earlySingletonObjects = new HashMap(16);
```

这三级缓存的作用分别是：

- singletonFactories ： 进入实例化阶段的单例对象工厂的cache （三级缓存）；
- earlySingletonObjects ：完成实例化但是尚未初始化的，提前暴光的单例对象的Cache （二级缓存）；
- singletonObjects：完成初始化的单例对象的cache（一级缓存）。

我们在创建bean的时候，会首先从cache中获取这个bean，这个缓存就是sigletonObjects。主要的调用方法是：

```
protected Object getSingleton(String beanName, boolean allowEarlyReference) {     Object singletonObject = this.singletonObjects.get(beanName);     //isSingletonCurrentlyInCreation()判断当前单例bean是否正在创建中     if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {         synchronized (this.singletonObjects) {             singletonObject = this.earlySingletonObjects.get(beanName);             //allowEarlyReference 是否允许从singletonFactories中通过getObject拿到对象             if (singletonObject == null && allowEarlyReference) {                 ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);                 if (singletonFactory != null) {                     singletonObject = singletonFactory.getObject();                     //从singletonFactories中移除，并放入earlySingletonObjects中。                     //其实也就是从三级缓存移动到了二级缓存                     this.earlySingletonObjects.put(beanName, singletonObject);                     this.singletonFactories.remove(beanName);                 }             }         }     }     return (singletonObject != NULL_OBJECT ? singletonObject : null); }
```

从上面三级缓存的分析，我们可以知道，Spring解决循环依赖的诀窍就在于singletonFactories这个三级cache。这个cache的类型是ObjectFactory，定义如下：

```
public interface ObjectFactory<T> {     T getObject() throws BeansException; }
```

这个接口在AbstractBeanFactory里实现，并在核心方法doCreateBean（）引用下面的方法：

```
protected void addSingletonFactory(String beanName, ObjectFactory<?> singletonFactory) {     Assert.notNull(singletonFactory, "Singleton factory must not be null");     synchronized (this.singletonObjects) {         if (!this.singletonObjects.containsKey(beanName)) {             this.singletonFactories.put(beanName, singletonFactory);             this.earlySingletonObjects.remove(beanName);             this.registeredSingletons.add(beanName);         }     } }
```

这段代码发生在createBeanInstance之后，populateBean（）之前，也就是说单例对象此时已经被创建出来(调用了构造器)。这个对象已经被生产出来了，此时将这个对象提前曝光出来，让大家使用。

这样做有什么好处呢？让我们来分析一下“A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象”这种循环依赖的情况。A首先完成了初始化的第一步，并且将自己提前曝光到singletonFactories中，此时进行初始化的第二步，发现自己依赖对象B，此时就尝试去get(B)，发现B还没有被create，所以走create流程，B在初始化第一步的时候发现自己依赖了对象A，于是尝试get(A)，尝试一级缓存singletonObjects(肯定没有，因为A还没初始化完全)，尝试二级缓存earlySingletonObjects（也没有），尝试三级缓存singletonFactories，由于A通过ObjectFactory将自己提前曝光了，所以B能够通过ObjectFactory.getObject拿到A对象(虽然A还没有初始化完全，但是总比没有好呀)，B拿到A对象后顺利完成了初始化阶段1、2、3，完全初始化之后将自己放入到一级缓存singletonObjects中。此时返回A中，A此时能拿到B的对象顺利完成自己的初始化阶段2、3，最终A也完成了初始化，进去了一级缓存singletonObjects中，而且更加幸运的是，由于B拿到了A的对象引用，所以B现在hold住的A对象完成了初始化。

#### @Autowired和@Resource注解有什么区别？

**参考答案**

1. @Autowired是Spring提供的注解，@Resource是JDK提供的注解。
2. @Autowired是只能按类型注入，@Resource默认按名称注入，也支持按类型注入。
3. @Autowired按类型装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它required属性为false，如果我们想使用按名称装配，可以结合@Qualifier注解一起使用。@Resource有两个中重要的属性：name和type。name属性指定byName，如果没有指定name属性，当注解标注在字段上，即默认取字段的名称作为bean名称寻找依赖对象，当注解标注在属性的setter方法上，即默认取属性名作为bean名称寻找依赖对象。需要注意的是，@Resource如果没有指定name属性，并且按照默认的名称仍然找不到依赖对象时， @Resource注解会回退到按类型装配。但一旦指定了name属性，就只能按名称装配了。

#### Spring中默认提供的单例是线程安全的吗？

**参考答案**

不是。

Spring容器本身并没有提供Bean的线程安全策略。如果单例的Bean是一个无状态的Bean，即线程中的操作不会对Bean的成员执行查询以外的操作，那么这个单例的Bean是线程安全的。比如，Controller、Service、DAO这样的组件，通常都是单例且线程安全的。如果单例的Bean是一个有状态的Bean，则可以采用ThreadLocal对状态数据做线程隔离，来保证线程安全。

#### 说一说你对Spring AOP的理解

**参考答案**

AOP（Aspect Oriented Programming）是面向切面编程，它是一种编程思想，是面向对象编程（OOP）的一种补充。面向对象编程将程序抽象成各个层次的对象，而面向切面编程是将程序抽象成各个切面。所谓切面，相当于应用对象间的横切点，我们可以将其单独抽象为单独的模块。

AOP的术语：

- 连接点（join point）：对应的是具体被拦截的对象，因为Spring只能支持方法，所以被拦截的对象往往就是指特定的方法，AOP将通过动态代理技术把它织入对应的流程中。
- 切点（point cut）：有时候，我们的切面不单单应用于单个方法，也可能是多个类的不同方法，这时，可以通过正则式和指示器的规则去定义，从而适配连接点。切点就是提供这样一个功能的概念。
- 通知（advice）：就是按照约定的流程下的方法，分为前置通知、后置通知、环绕通知、事后返回通知和异常通知，它会根据约定织入流程中。
- 目标对象（target）：即被代理对象。
- 引入（introduction）：是指引入新的类和其方法，增强现有Bean的功能。
- 织入（weaving）：它是一个通过动态代理技术，为原有服务对象生成代理对象，然后将与切点定义匹配的连接点拦截，并按约定将各类通知织入约定流程的过程。
- 切面（aspect）：是一个可以定义切点、各类通知和引入的内容，SpringAOP将通过它的信息来增强Bean的功能或者将对应的方法织入流程。

Spring AOP：

AOP可以有多种实现方式，而Spring AOP支持如下两种实现方式。

- JDK动态代理：这是Java提供的动态代理技术，可以在运行时创建接口的代理实例。Spring AOP默认采用这种方式，在接口的代理实例中织入代码。
- CGLib动态代理：采用底层的字节码技术，在运行时创建子类代理的实例。当目标对象不存在接口时，Spring AOP就会采用这种方式，在子类实例中织入代码。

#### 请你说说AOP的应用场景

**参考答案**

Spring AOP为IoC的使用提供了更多的便利，一方面，应用可以直接使用AOP的功能，设计应用的横切关注点，把跨越应用程序多个模块的功能抽象出来，并通过简单的AOP的使用，灵活地编制到模块中，比如可以通过AOP实现应用程序中的日志功能。另一方面，在Spring内部，一些支持模块也是通过Spring AOP来实现的，比如事务处理。从这两个角度就已经可以看到Spring AOP的核心地位了。

#### Spring AOP不能对哪些类进行增强？

**参考答案**

1. Spring AOP只能对IoC容器中的Bean进行增强，对于不受容器管理的对象不能增强。
2. 由于CGLib采用动态创建子类的方式生成代理对象，所以不能对final修饰的类进行代理。

####  JDK动态代理和CGLIB有什么区别？

**参考答案**

JDK动态代理

这是Java提供的动态代理技术，可以在运行时创建接口的代理实例。Spring AOP默认采用这种方式，在接口的代理实例中织入代码。

CGLib动态代理

采用底层的字节码技术，在运行时创建子类代理的实例。当目标对象不存在接口时，Spring AOP就会采用这种方式，在子类实例中织入代码。

#### 既然有没有接口都可以用CGLIB，为什么Spring还要使用JDK动态代理？

**参考答案**

在性能方面，CGLib创建的代理对象比JDK动态代理创建的代理对象高很多。但是，CGLib在创建代理对象时所花费的时间比JDK动态代理多很多。所以，对于单例的对象因为无需频繁创建代理对象，采用CGLib动态代理比较合适。反之，对于多例的对象因为需要频繁的创建代理对象，则JDK动态代理更合适。

#### Spring如何管理事务？

**参考答案**

Spring为事务管理提供了一致的编程模板，在高层次上建立了统一的事务抽象。也就是说，不管是选择MyBatis、Hibernate、JPA还是Spring JDBC，Spring都可以让用户以统一的编程模型进行事务管理。

Spring支持两种事务编程模型：

1. 编程式事务

   Spring提供了TransactionTemplate模板，利用该模板我们可以通过编程的方式实现事务管理，而无需关注资源获取、复用、释放、事务同步及异常处理等操作。相对于声明式事务来说，这种方式相对麻烦一些，但是好在更为灵活，我们可以将事务管理的范围控制的更为精确。

2. 声明式事务

   Spring事务管理的亮点在于声明式事务管理，它允许我们通过声明的方式，在IoC配置中指定事务的边界和事务属性，Spring会自动在指定的事务边界上应用事务属性。相对于编程式事务来说，这种方式十分的方便，只需要在需要做事务管理的方法上，增加@Transactional注解，以声明事务特征即可。

#### Spring的事务传播方式有哪些？

**参考答案**

当我们调用一个业务方法时，它的内部可能会调用其他的业务方法，以完成一个完整的业务操作。这种业务方法嵌套调用的时候，如果这两个方法都是要保证事务的，那么就要通过Spring的事务传播机制控制当前事务如何传播到被嵌套调用的业务方法中。

Spring在TransactionDefinition接口中规定了7种类型的事务传播行为，它们规定了事务方法和事务方法发生嵌套调用时如何进行传播，如下表：

| 事务传播类型              | 说明                                                         |
| :------------------------ | :----------------------------------------------------------- |
| PROPAGATION_REQUIRED      | 如果当前没有事务，则新建一个事务；如果已存在一个事务，则加入到这个事务中。这是最常见的选择。 |
| PROPAGATION_SUPPORTS      | 支持当前事务，如果当前没有事务，则以非事务方式执行。         |
| PROPAGATION_MANDATORY     | 使用当前的事务，如果当前没有事务，则抛出异常。               |
| PROPAGATION_REQUIRES_NEW  | 新建事务，如果当前存在事务，则把当前事务挂起。               |
| PROPAGATION_NOT_SUPPORTED | 以非事务方式执行操作，如果当前存在事务，则把当前事务挂起。   |
| PROPAGATION_NEVER         | 以非事务方式执行操作，如果当前存在事务，则抛出异常。         |
| PROPAGATION_NESTED        | 如果当前存在事务，则在嵌套事务内执行；如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。 |

#### Spring的事务如何配置，常用注解有哪些？

**参考答案**

事务的打开、回滚和提交是由事务管理器来完成的，我们使用不同的数据库访问框架，就要使用与之对应的事务管理器。在Spring Boot中，当你添加了数据库访问框架的起步依赖时，它就会进行自动配置，即自动实例化正确的事务管理器。

对于声明式事务，是使用@Transactional进行标注的。这个注解可以标注在类或者方法上。

- 当它标注在类上时，代表这个类所有公共（public）非静态的方法都将启用事务功能。
- 当它标注在方法上时，代表这个方法将启用事务功能。

另外，在@Transactional注解上，我们可以使用isolation属性声明事务的隔离级别，使用propagation属性声明事务的传播机制。

#### 说一说你对声明式事务的理解

**参考答案**

Spring事务管理的亮点在于声明式事务管理，它允许我们通过声明的方式，在IoC配置中指定事务的边界和事务属性，Spring会自动在指定的事务边界上应用事务属性。相对于编程式事务来说，这种方式十分的方便，只需要在需要做事务管理的方法上，增加@Transactional注解，以声明事务特征即可。

## Spring MVC

#### 什么是MVC？

**参考答案**

MVC是一种设计模式，在这种模式下软件被分为三层，即Model（模型）、View（视图）、Controller（控制器）。Model代表的是数据，View代表的是用户界面，Controller代表的是数据的处理逻辑，它是Model和View这两层的桥梁。将软件分层的好处是，可以将对象之间的耦合度降低，便于代码的维护。

#### DAO层是做什么的？

**参考答案**

DAO是Data Access Object的缩写，即数据访问对象，在项目中它通常作为独立的一层，专门用于访问数据库。这一层的具体实现技术有很多，常用的有Spring JDBC、Hibernate、JPA、MyBatis等，在Spring框架下无论采用哪一种技术访问数据库，它的编程模式都是统一的。

#### SpringMVC的工作原理有了解嘛？

1.  客户端（浏览器）发送请求，直接请求到 DispatcherServlet。
2.  DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求对应的 Handler。
3.  解析到对应的 Handler（也就是我们平常说的 Controller 控制器）后，开始由 HandlerAdapter 适配器处理。
4.  HandlerAdapter 会根据 Handler来调用真正的处理器开处理请求，并处理相应的业务逻辑。
5.  处理器处理完业务后，会返回一个 ModelAndView 对象，Model 是返回的数据对象，View 是个逻辑上的 View。
6.  ViewResolver 会根据逻辑 View 查找实际的 View。
7.  DispaterServlet 把返回的 Model 传给 View（视图渲染）。
8.  把 View 返回给请求者（浏览器）



#### 介绍一下Spring MVC的执行流程

**参考答案**

1. 整个过程开始于客户端发出的一个HTTP请求，Web应用服务器接收到这个请求。如果匹配DispatcherServlet的请求映射路径，则Web容器将该请求转交给DispatcherServlet处理。
2. DispatcherServlet接收到这个请求后，将根据请求的信息（包括URL、HTTP方法、请求报文头、请求参数、Cookie等）及HandlerMapping的配置找到处理请求的处理器（Handler）。可将HandlerMapping看做路由控制器，将Handler看做目标主机。值得注意的是，在Spring MVC中并没有定义一个Handler接口，实际上任何一个Object都可以成为请求处理器。
3. 当DispatcherServlet根据HandlerMapping得到对应当前请求的Handler后，通过HandlerAdapter对Handler进行封装，再以统一的适配器接口调用Handler。HandlerAdapter是Spring MVC框架级接口，顾名思义，HandlerAdapter是一个适配器，它用统一的接口对各种Handler方法进行调用。
4. 处理器完成业务逻 辑的处理后，将返回一个ModelAndView给DispatcherServlet，ModelAndView包含了视图逻辑名和模型数据信息。
5. ModelAndView中包
6. 含的是“逻辑视图名”而非真正的视图对象，DispatcherServlet借由ViewResolver完成逻辑视图名到真实视图对象的解析工作。
7. 当得到真实的视图对象View后，DispatcherServlet就使用这个View对象对ModelAndView中的模型数据进行视图渲染。
8. 最终客户端得到的响应消息可能是一个普通的HTML页面，也可能是一个XML或JSON串，甚至是一张图片或一个PDF文档等不同的媒体形式。

#### 说一说你知道的Spring MVC注解

**参考答案**

@RequestMapping：

作用：该注解的作用就是用来处理请求地址映射的，也就是说将其中的处理器方法映射到url路径上。

属性：

- method：是让你指定请求的method的类型，比如常用的有get和post。
- value：是指请求的实际地址，如果是多个地址就用{}来指定就可以啦。
- produces：指定返回的内容类型，当request请求头中的Accept类型中包含指定的类型才可以返回的。
- consumes：指定处理请求的提交内容类型，比如一些json、html、text等的类型。
- headers：指定request中必须包含那些的headed值时，它才会用该方法处理请求的。
- params：指定request中一定要有的参数值，它才会使用该方法处理请求。

@RequestParam：

作用：是将请求参数绑定到你的控制器的方法参数上，是Spring MVC中的接收普通参数的注解。

属性：

- value是请求参数中的名称。
- required是请求参数是否必须提供参数，它的默认是true，意思是表示必须提供。

@RequestBody：

作用：如果作用在方法上，就表示该方法的返回结果是直接按写入的Http responsebody中（一般在异步获取数据时使用的注解）。

属性：required，是否必须有请求体。它的默认值是true，在使用该注解时，值得注意的当为true时get的请求方式是报错的，如果你取值为false的话，get的请求是null。

@PathVaribale：

作用：该注解是用于绑定url中的占位符，但是注意，spring3.0以后，url才开始支持占位符的，它是Spring MVC支持的rest风格url的一个重要的标志。

#### 介绍一下Spring MVC的拦截器

**参考答案**

拦截器会对处理器进行拦截，这样通过拦截器就可以增强处理器的功能。Spring MVC中，所有的拦截器都需要实现HandlerInterceptor接口，该接口包含如下三个方法：preHandle()、postHandle()、afterCompletion()。

这些方法的执行流程如下图：

![img](https://uploadfiles.nowcoder.com/images/20220224/4107856_1645694469544/31C010B3F63CB1CC1ADC5481E9E77BDB)

通过上图可以看出，Spring MVC拦截器的执行流程如下：

- 执行preHandle方法，它会返回一个布尔值。如果为false，则结束所有流程，如果为true，则执行下一步。
- 执行处理器逻辑，它包含控制器的功能。
- 执行postHandle方法。
- 执行视图解析和视图渲染。
- 执行afterCompletion方法。

Spring MVC拦截器的开发步骤如下：

1. 开发拦截器：

   实现handlerInterceptor接口，从三个方法中选择合适的方法，实现拦截时要执行的具体业务逻辑。

2. 注册拦截器：

   定义配置类，并让它实现WebMvcConfigurer接口，在接口的addInterceptors方法中，注册拦截器，并定义该拦截器匹配哪些请求路径。

#### 怎么去做请求拦截？

**参考答案**

如果是对Controller记性拦截，则可以使用Spring MVC的拦截器。

如果是对所有的请求（如访问静态资源的请求）进行拦截，则可以使用Filter。

如果是对除了Controller之外的其他Bean的请求进行拦截，则可以使用Spring AOP。

## Spring Boot

```
@ConfigurationProperties(prefix = "spring.task.execution.pool")
@value
```

#### Spring和springboot都有什么区别？spirngboot最大的优势是什么？

`SpringBoot`基本上是 `Spring`框架的扩展，它消除了设置 `Spring`应用程序所需的 `XML配置`，为更快，更高效

#### 如何自定义一个springboot starter?

#### 请描述Spring Boot自动装配的过程？

整个自动装配的过程是：Spring Boot通过@EnableAutoConfiguration注解开启自动配置，加载spring.factories中注册的各种AutoConfiguration类，当某个AutoConfiguration类满足其注解@Conditional指定的生效条件时，实例化该AutoConfiguration类中定义的Bean（组件等），并注入Spring容器，就可以完成依赖框架的自动配置。

#### 说说你对Spring Boot的理解

**参考答案**

从本质上来说，Spring Boot就是Spring，它做了那些没有它你自己也会去做的Spring Bean配置。Spring Boot使用“习惯优于配置”的理念让你的项目快速地运行起来，使用Spring Boot很容易创建一个能独立运行、准生产级别、基于Spring框架的项目，使用Spring Boot你可以不用或者只需要很少的Spring配置。

简而言之，Spring Boot本身并不提供Spring的核心功能，而是作为Spring的脚手架框架，以达到快速构建项目、预置三方配置、开箱即用的目的。Spring Boot有如下的优点：

- 可以快速构建项目；
- 可以对主流开发框架的无配置集成；
- 项目可独立运行，无需外部依赖Servlet容器；
- 提供运行时的应用监控；
- 可以极大地提高开发、部署效率；
- 可以与云计算天然集成。

#### Spring Boot Starter有什么用？

**参考答案**

Spring Boot通过提供众多起步依赖（Starter）降低项目依赖的复杂度。起步依赖本质上是一个Maven项目对象模型（Project Object Model, POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。很多起步依赖的命名都暗示了它们提供的某种或某类功能。

举例来说，你打算把这个阅读列表应用程序做成一个Web应用程序。与其向项目的构建文件里添加一堆单独的库依赖，还不如声明这是一个Web应用程序来得简单。你只要添加Spring Boot的Web起步依赖就好了。

#### 介绍Spring Boot的启动流程

**参考答案**

首先，Spring Boot项目创建完成会默认生成一个名为 *Application 的入口类，我们是通过该类的main方法启动Spring Boot项目的。在main方法中，通过SpringApplication的静态方法，即run方法进行SpringApplication类的实例化操作，然后再针对实例化对象调用另外一个run方法来完成整个项目的初始化和启动。

SpringApplication调用的run方法的大致流程，如下图：

![img](https://uploadfiles.nowcoder.com/images/20220224/4107856_1645694256551/4ECC3AECD1D8D2B62421E2D3453DC465)

其中，SpringApplication在run方法中重点做了以下操作：

- 获取监听器和参数配置；
- 打印Banner信息；
- 创建并初始化容器；
- 监听器发送通知。

当然，除了上述核心操作，run方法运行过程中还涉及启动时长统计、异常报告、启动日志、异常处理等辅助操作。比较完整的流程，可以参考如下源代码：

```
public ConfigurableApplicationContext run(String... args) {     // 创建StopWatch对象，用于统计run方法启动时长。     StopWatch stopWatch = new StopWatch();     // 启动统计     stopWatch.start();     ConfigurableApplicationContext context = null;     Collection<SpringBootExceptionReporter> exceptionReporters = new ArrayList<>();     // 配置Headless属性     configureHeadlessProperty();     // 获得SpringApplicationRunListener数组，     // 该数组封装于SpringApplicationRunListeners对象的listeners中。     SpringApplicationRunListeners listeners = getRunListeners(args);     // 启动监听，遍历SpringApplicationRunListener数组每个元素，并执行。     listeners.starting();     try {         // 创建ApplicationArguments对象         ApplicationArguments applicationArguments =              new DefaultApplicationArguments(args);         // 加载属性配置，包括所有的配置属性。         ConfigurableEnvironment environment =              prepareEnvironment(listeners, applicationArguments);         configureIgnoreBeanInfo(environment);         // 打印Banner         Banner printedBanner = printBanner(environment);         // 创建容器         context = createApplicationContext();         // 异常报告器         exceptionReporters = getSpringFactoriesInstances(             SpringBootExceptionReporter.class,             new Class[] { ConfigurableApplicationContext.class }, context);         // 准备容器，组件对象之间进行关联。         prepareContext(context, environment,                         listeners, applicationArguments, printedBanner);         // 初始化容器         refreshContext(context);         // 初始化操作之后执行，默认实现为空。         afterRefresh(context, applicationArguments);         // 停止时长统计         stopWatch.stop();         // 打印启动日志         if (this.logStartupInfo) {             new StartupInfoLogger(this.mainApplicationClass)                 .logStarted(getApplicationLog(), stopWatch);         }         // 通知监听器：容器完成启动。         listeners.started(context);         // 调用ApplicationRunner和CommandLineRunner的运行方法。         callRunners(context, applicationArguments);     } catch (Throwable ex) {         // 异常处理         handleRunFailure(context, ex, exceptionReporters, listeners);         throw new IllegalStateException(ex);     }      try {         // 通知监听器：容器正在运行。         listeners.running(context);     } catch (Throwable ex) {         // 异常处理         handleRunFailure(context, ex, exceptionReporters, null);         throw new IllegalStateException(ex);     }     return context; }
```

#### Spring Boot项目是如何导入包的？

**参考答案**

通过Spring Boot Starter导入包。

Spring Boot通过提供众多起步依赖（Starter）降低项目依赖的复杂度。起步依赖本质上是一个Maven项目对象模型（Project Object Model, POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。很多起步依赖的命名都暗示了它们提供的某种或某类功能。

举例来说，你打算把这个阅读列表应用程序做成一个Web应用程序。与其向项目的构建文件里添加一堆单独的库依赖，还不如声明这是一个Web应用程序来得简单。你只要添加Spring Boot的Web起步依赖就好了。

#### 请描述Spring Boot自动装配的过程

**参考答案**

使用Spring Boot时，我们只需引入对应的Starters，Spring Boot启动时便会自动加载相关依赖，配置相应的初始化参数，以最快捷、简单的形式对第三方软件进行集成，这便是Spring Boot的自动配置功能。Spring Boot实现该运作机制锁涉及的核心部分如下图所示：

![img](https://uploadfiles.nowcoder.com/images/20220224/4107856_1645694273137/4C6D51AEA1E10E3717A8BE4AE88B6F79)

整个自动装配的过程是：Spring Boot通过@EnableAutoConfiguration注解开启自动配置，加载spring.factories中注册的各种AutoConfiguration类，当某个AutoConfiguration类满足其注解@Conditional指定的生效条件（Starters提供的依赖、配置或Spring容器中是否存在某个Bean等）时，实例化该AutoConfiguration类中定义的Bean（组件等），并注入Spring容器，就可以完成依赖框架的自动配置。

#### 说说你对Spring Boot注解的了解

**参考答案**

@SpringBootApplication注解：

在Spring Boot入口类中，唯一的一个注解就是@SpringBootApplication。它是Spring Boot项目的核心注解，用于开启自动配置，准确说是通过该注解内组合的@EnableAutoConfiguration开启了自动配置。

@EnableAutoConfiguration注解：

@EnableAutoConfiguration的主要功能是启动Spring应用程序上下文时进行自动配置，它会尝试猜测并配置项目可能需要的Bean。自动配置通常是基于项目classpath中引入的类和已定义的Bean来实现的。在此过程中，被自动配置的组件来自项目自身和项目依赖的jar包中。

@Import注解：

@EnableAutoConfiguration的关键功能是通过@Import注解导入的ImportSelector来完成的。从源代码得知@Import(AutoConfigurationImportSelector.class)是@EnableAutoConfiguration注解的组成部分，也是自动配置功能的核心实现者。

@Conditional注解：

@Conditional注解是由Spring 4.0版本引入的新特性，可根据是否满足指定的条件来决定是否进行Bean的实例化及装配，比如，设定当类路径下包含某个jar包的时候才会对注解的类进行实例化操作。总之，就是根据一些特定条件来控制Bean实例化的行为。

@Conditional衍生注解：

在Spring Boot的autoconfigure项目中提供了各类基于@Conditional注解的衍生注解，它们适用不同的场景并提供了不同的功能。通过阅读这些注解的源码，你会发现它们其实都组合了@Conditional注解，不同之处是它们在注解中指定的条件（Condition）不同。

- @ConditionalOnBean：在容器中有指定Bean的条件下。
- @ConditionalOnClass：在classpath类路径下有指定类的条件下。
- @ConditionalOnCloudPlatform：当指定的云平台处于active状态时。
- @ConditionalOnExpression：基于SpEL表达式的条件判断。
- @ConditionalOnJava：基于JVM版本作为判断条件。
- @ConditionalOnJndi：在JNDI存在的条件下查找指定的位置。
- @ConditionalOnMissingBean：当容器里没有指定Bean的条件时。
- @ConditionalOnMissingClass：当类路径下没有指定类的条件时。
- @ConditionalOnNotWebApplication：在项目不是一个Web项目的条件下。
- @ConditionalOnProperty：在指定的属性有指定值的条件下。
- @ConditionalOnResource：类路径是否有指定的值。
- @ConditionalOnSingleCandidate：当指定的Bean在容器中只有一个或者有多个但是指定了首选的Bean时。
- @ConditionalOnWebApplication：在项目是一个Web项目的条件下。

## 微服务

#### SpringCloud

每个服务都围绕着具体业务进行构建，并且 能够被独立的部署到生产环境.

微服务架构是一种架构风格，它将应用程序构建为以业务域为模型的小型 自治服务集合。

服务注册发现 nacos 

配置中心 nacos

网关 gateway

远程调用 open feign

服务降级

负载均衡: 尽力将网络流量平均分发到多个服务器上，以提高系统整体的响应速度和可用性。

#### 微服务特点:

独立开发 – 所有微服务都可以根据各自的功能轻松开发
独立部署 – 基于其服务，可以在任何应用程序中单独部署它们 故障隔离 – 即使应用程序的一项服务不起作用，系统仍可继续运行 

混合技术堆栈 – 可以使用不同的语言和技术来构建同一应用程序的不同

粒度缩放 –

#### 分布式锁

#### 分布式事务

#### 分布式缓存



## 其他

#### 如何在SpringBoot框架下实现一个定时任务？

**参考答案**

Spring给我们提供了可执行定时任务的线程池ThreadPoolTaskScheduler，该线程池提供了多个可以与执行定时任务的方法，如下图。在Spring Boot中，只需要在配置类中启用线程池注解，就可以直接使用这个线程池了。

![img](https://uploadfiles.nowcoder.com/images/20220224/4107856_1645701177525/D5738E9CC452DEB565C933A55C36FBFB)

#### 调用接口时要记录日志，该怎么设计？

**参考答案**

可以定义一个记录日志的组件，并通过AOP将其织入到这个接口的调用中。这种方式对接口无需做任何改造，业务代码中也无需增加任何调用的逻辑，完美地消除了记录日志和业务代码的耦合度。

#### 了解Spring Boot JPA吗？

**参考答案**

JPA即Java Persistence API，它是一个基于O/R映射的标准规范。也就是说它指定以了标准规则，不提供实现，软件提供商可以按照标准规范来实现，而使用者只需按照规范中定义的方式来使用，不用和软件提供商打交道。JPA主要实现有Hibernate、EclipseLink、OpenJPA等，我们使用JPA来开发，无论是采用哪一种实现方式都一样。

## web问题

#### TCP模型五层模型

应用层：FTP、SMTP、POP3、HTTP、DNS、TELnet

传输层：TCP、UDP

网络层：路由器   ICMP、ARP、RARP、IP、IGMP、OSPF

数据链路层：交换机、网桥；PPP,HDLC、SDLC、STP、ARQ

物理层：集线器，中继器

#### forward,与redirect 的区别?有哪些方式实现

forward是把另一个页面加载到本页面，不改变浏览器的路径，redirect是跳转到另一个页面，会改变浏览器的路径
重定向:   response.sendRedirect(“重定向的路径”)
转发: request.getRequestDispatcher(“转发路径”) .forward(request, response);

#### http与https区别？

1、https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。

2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl/tls加密传输协议。

3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

4、http的连接很简单，是无状态的；HTTPS协议是由SSL/TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

#### TCP与UDP的区别？

- 首先 TCP 面向连接，而 UDP 是无连接的。
- TCP 注重提供可靠的服务。能保证连接传送的数据，无差错，不丢失，不重复，且按序到达。而 UDP 是尽最大努力交付，即不保证可靠交付。
- UDP 协议就比较适合用于实时音视频通讯，首先它是允许端到端的全链条信道策略控制，可以保证弱网环境下播放的流畅性。在丢包方面 UDP 协议也更加灵活，方便我们在视频流畅与画质之间做好平衡。

#### 当你在浏览器中输入一串地址，敲完回车，知道页面的最终结果展现给用户，整个过程中用技术描述一下都发生了什么？

1（域名解析）在客户端，浏览器输入地址后，首先会在windows系统文件的hosts中查找是否有对应的ip地址，如果没有则需要向DNS域名解析服务器询问该域名对应的ip地址。

2.（TCP三次握手）获取相应的ip地址后，客户端与服务器端建立TCP连接（三次握手），（网络层，数据链路层，物理层）

三次握手-->

第一次握手：客户端向服务器端发送一个SYN段，该段中包含客户端的初始序列号。

第二次握手：服务器端返回客户端SYN+ACK，该端中包含服务器端的初始序列号，ACK表示，已经确定收到客户端的SYN段。

第三次握手：客户端向服务器端响应一个ACK端，ACK表示，已经确定接受到服务器端的SYN段。

3.（建立起TCP连接后发起http请求）客户端向服务器端发送请求，包含请求行，请求头。主要的两种请求方式（GET与POST）

-->GET:请求能够携带的参数比较少，大小有限制，会在浏览器的URL地址栏显示数据的内容，不安全，但高效。

-->POST:请求能够携带的参数没有限制，大小没有限制，不会在浏览器的URL地址栏显示数据内容，安全，但不高效。

4.（服务器响应http请求）服务器处理请求，并返回响应，包含状态码，响应头，响应体。

5（浏览器解析http代码）浏览器收到响应，解析http代码渲染页面，并在浏览器页面展示出来。

6.（断开连接）http1.0短连接，http1.1长连接。

#### 如何解决跨域？

跨域：指的是浏览器不能执行其他网站的脚本。它是由浏览器的[同源策略](https://so.csdn.net/so/search?q=同源策略&spm=1001.2101.3001.7020)造成的，是浏览器施加的安全限制。

所谓同源是指，**域名，协议，端口**均相同

1.前端方法就用jsonp

2.后台配置解决跨域

3.通过 CORS解决跨域

springboot解决跨域？

```
@CrossOrigin

@Configuration
public class CorsConfig implements WebMvcConfigurer {

//    @Override
//    public void addCorsMappings(CorsRegistry registry) {
//        registry.addMapping("/**")
//            .allowedOrigins("*")
//            


//            .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
//            .maxAge(3600);
//    }
}
```

#### 解决跨域后如何保证数据一致性？

#### cookie和session的区别是什么？

**参考答案**

1. 存储位置不同：cookie存放于客户端；session存放于服务端。
2. 存储容量不同：单个cookie保存的数据<=4KB，一个站点最多保存20个cookie；而session并没有上限。
3. 存储方式不同：cookie只能保存ASCII字符串，并需要通过编码当时存储为Unicode字符或者二进制数据；session中能够存储任何类型的数据，例如字符串、整数、集合等。
4. 隐私策略不同：cookie对客户端是可见的，别有用心的人可以分析存放在本地的cookie并进行cookie欺骗，所以它是不安全的；session存储在服务器上，对客户端是透明的，不存在敏感信息泄露的风险。
5. 生命周期不同：可以通过设置cookie的属性，达到cookie长期有效的效果；session依赖于名为JSESSIONID的cookie，而该cookie的默认过期时间为-1，只需关闭窗口该session就会失效，因此session不能长期有效。
6. 服务器压力不同：cookie保存在客户端，不占用服务器资源；session保管在服务器上，每个用户都会产生一个session，如果并发量大的话，则会消耗大量的服务器内存。
7. 浏览器支持不同：cookie是需要浏览器支持的，如果客户端禁用了cookie，则会话跟踪就会失效；运用session就需要使用URL重写的方式，所有用到session的URL都要进行重写，否则session会话跟踪也会失效。
8. 跨域支持不同：cookie支持跨域访问，session不支持跨域访问。

#### cookie和session各自适合的场景是什么？

**参考答案**

对于敏感数据，应存放在session里，因为cookie不安全。

对于普通数据，优先考虑存放在cookie里，这样会减少对服务器资源的占用。

#### 请介绍session的工作原理

**参考答案**

session依赖于cookie。

当客户端首次访问服务器时，服务器会为其创建一个session对象，该对象具有一个唯一标识SESSIONID。并且在响应阶段，服务器会创建一个cookie，并将SESSIONID存入其中。

客户端通过响应的cookie而持有SESSIONID，所以当它再次访问服务器时，会通过cookie携带这个SESSIONID。服务器获取到SESSIONID后，就可以找到与之对应的session对象，进而从这个session中获取该客户端的状态。

#### get请求与post请求有什么区别？

**参考答案**

- GET在浏览器回退时是无害的，而POST会再次提交请求。
- GET产生的URL地址可以被Bookmark，而POST不可以。
- GET请求会被浏览器主动cache，而POST不会，除非手动设置。
- GET请求只能进行url编码，而POST支持多种编码方式。
- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
- GET请求在URL中传送的参数是有长度限制的，而POST没有。
- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
- GET参数通过URL传递，POST放在Request body中。

#### get请求的参数能放到body里面吗？

**参考答案**

GET请求是可以将参数放到BODY里面的，官方并没有明确禁止，但给出的建议是这样不符合规范，无法保证所有的实现都支持。这就意味着，如果你试图这样做，可能出现各种未知的问题，所以应该当避免。

#### post不幂等是为什么？

**参考答案**

HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。幂等性属于语义范畴，正如编译器只能帮助检查语法错误一样，HTTP规范也没有办法通过消息格式等语法手段来定义它。

POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：POST http://www.forum.com/articles的语义是在http://www.forum.com/articles下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI。所以，POST方法不具备幂等性。

#### 页面报400错误是什么意思？

**参考答案**

400状态码标识请求的语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。通常情况下，是本次请求中包含有错误的参数，此时应该排查前端传递的参数。

#### 请求数据出现乱码该怎么处理？

**参考答案**

服务端出现请求乱码的原因是，客户端编码与服务器解码方案不一致，可以有如下几种解决办法：

1. 将获得的数据按照客户端编码转成BYTE，再将BYTE按服务端编码转成字符串，这种方案对各种请求方式均有效，但是十分的麻烦。
2. 在接受请求数据之前，显示声明实体内容的编码与服务器一致，这种方式只对POST请求有效。
3. 修改服务器的配置文件，显示声明请求路径的编码与服务器一致，这种方式只对GET请求有效。

#### 常见状态码？

1xx	Informational（信息性状态码）	接受的请求正在处理
2xx	Success（成功状态码）	请求正常处理完毕
3xx	Redirection（重定向）	需要进行附加操作以完成请求
4xx	Client error（客户端错误）	客户端请求出错，服务器无法处理请求
5xx	Server Error（服务器错误）	服务器处理请求出错

## 完整面试流程

1. 你们公司的主要业务是什么？
2. 你在这家公司一共参与了哪几个项目？
3. 在这些项目中你分别担任什么角色？
4. 你参与的项目都使用了哪些技术栈？
5. Mybatis和JPA有什么区别？
6. 你们团队为什么选择Mybatis而没有选择JPA?
7. 在你做的项目中你认为哪些点还可以进行技术上的优化？
8. 在什么样的业务场景下会使用到消息中间件？
9. 使用消息中间件，在消息丢失的情况下如何补救？
10. 谈谈你对spring的理解？
11. springbean的生命周期是什么样？
12. 你认为spring是线程安全的吗？
13. 如果我现在要在controller里面定义一个全局变量，还要要求他线程安全，用什么技术方案来保证它？
14. 除了spring，你们项目中还用过其他什么框架，这些框架都分别解决了什么问题？
15. 如果系统中出现跨域这种情况，如果保证用户状态的一致性？
16. Redis的缓存淘汰机制是什么？
17. Redis和Memcached的区别是什么？
18. 第一个电商项目在上线之初，你们是否进行了压力测试，都采用那些测试方案，用了哪些压测工具，测试后得到的QPS是多少？
19. java中的重写和覆盖有什么区别，这样设计有什么优势？是否在项目中使用过，能否举个例子？
20. java中的深拷贝与浅拷贝有什么区别？
21. java中如何实现深拷贝？
22. 静态变量和实体变量有什么区别？这样设计在使用中有什么好处？
23. HashMap和HashTable有什么区别？他们底层数据结构是什么样的？
24. 如果要使用线程安全的Map该使用哪个集合？
25. 你会在什么情况下使用多线程？
26. 创建多线程都有哪几种方案？
27. 什么情况会出现线程死锁？
28. NIO和传统IO有什么区别？
29. 什么是Spring的IOC?
30. 什么是Spring中的控制反转？
31. IOC底层技术用什么实现的？
32. 控制反转的底层用什么实现的？这样设计对spring框架有什么好处？
33. Spring和springboot都有什么区别？spirngboot最大的优势是什么？
34. 如何自定义一个springboot starter?
35. 微服务最大优点是什么？最大缺点是什么？
36. SpringCloud生态最大优点是什么？
37. 你是什么数据库，在使用数据库时默认会选择什么样的数据引擎？
38. MyISAM和InnoDB有什么区别？
39. 数据库中的左连接，右连接，全连接是什么？
40. 项目设计分库分表，如何通过技术保持数据的一致性？
41. 当你在浏览器中输入一串地址，敲完回车，知道页面的最终结果展现给用户，整个过程中用技术描述一下都发生了什么？
42. 业余时间通过什么方式学习的？
43. 你看过的最好的一本技术书籍是什么？
44. 未来你对自己的职业规划是什么？
45. 你对我们这边还有什么想要了解的？
